<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Dependency Inversion for Camunda Tasks | ~stesie's musings</title>
<meta name=keywords content="Camunda,Dependency Inversion"><meta name=description content="In Camunda Service Tasks can be implemented using so-called delegate expressions, which, in the context of CDI, resolve to @Named annotated beans.
This task class has to implement the JavaDelegate interface, which mandates a method named execute, which receives a single argument with a DelegateExecution instance. However there is the Dependency Inversion Principle (DIP), and this way our business code directly depends on two classes from Camunda. Can&rsquo;t we do better?"><meta name=author content><link rel=canonical href=https://stefansiegl.de/2025/06/dependency-inversion-for-camunda-tasks/><link crossorigin=anonymous href=/assets/css/stylesheet.0c89971808195fcfba02b00128bb5209e165ff89d76c2f0d04eaefef9e1bd82a.css integrity="sha256-DImXGAgZX8+6ArABKLtSCeFl/4nXbC8NBOrv754b2Co=" rel="preload stylesheet" as=style><link rel=icon href=https://stefansiegl.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://stefansiegl.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://stefansiegl.de/favicon-32x32.png><link rel=apple-touch-icon href=https://stefansiegl.de/apple-touch-icon.png><link rel=mask-icon href=https://stefansiegl.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://stefansiegl.de/2025/06/dependency-inversion-for-camunda-tasks/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=me href=https://wue.social/@rolf><meta property="og:title" content="Dependency Inversion for Camunda Tasks"><meta property="og:description" content="In Camunda Service Tasks can be implemented using so-called delegate expressions, which, in the context of CDI, resolve to @Named annotated beans.
This task class has to implement the JavaDelegate interface, which mandates a method named execute, which receives a single argument with a DelegateExecution instance. However there is the Dependency Inversion Principle (DIP), and this way our business code directly depends on two classes from Camunda. Can&rsquo;t we do better?"><meta property="og:type" content="article"><meta property="og:url" content="https://stefansiegl.de/2025/06/dependency-inversion-for-camunda-tasks/"><meta property="article:section" content="pages"><meta property="article:published_time" content="2025-06-19T00:00:00+00:00"><meta property="article:modified_time" content="2025-06-19T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Dependency Inversion for Camunda Tasks"><meta name=twitter:description content="In Camunda Service Tasks can be implemented using so-called delegate expressions, which, in the context of CDI, resolve to @Named annotated beans.
This task class has to implement the JavaDelegate interface, which mandates a method named execute, which receives a single argument with a DelegateExecution instance. However there is the Dependency Inversion Principle (DIP), and this way our business code directly depends on two classes from Camunda. Can&rsquo;t we do better?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Pages","item":"https://stefansiegl.de/pages/"},{"@type":"ListItem","position":2,"name":"Dependency Inversion for Camunda Tasks","item":"https://stefansiegl.de/2025/06/dependency-inversion-for-camunda-tasks/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Dependency Inversion for Camunda Tasks","name":"Dependency Inversion for Camunda Tasks","description":"In Camunda Service Tasks can be implemented using so-called delegate expressions, which, in the context of CDI, resolve to @Named annotated beans.\nThis task class has to implement the JavaDelegate interface, which mandates a method named execute, which receives a single argument with a DelegateExecution instance. However there is the Dependency Inversion Principle (DIP), and this way our business code directly depends on two classes from Camunda. Can\u0026rsquo;t we do better?","keywords":["Camunda","Dependency Inversion"],"articleBody":"In Camunda Service Tasks can be implemented using so-called delegate expressions, which, in the context of CDI, resolve to @Named annotated beans.\nThis task class has to implement the JavaDelegate interface, which mandates a method named execute, which receives a single argument with a DelegateExecution instance. However there is the Dependency Inversion Principle (DIP), and this way our business code directly depends on two classes from Camunda. Canâ€™t we do better?\nWhat about providing an abstraction over the variable scopes and an interface of our own, tagging all our service classes? And afterward have implementation that binds these interfaces.\nFirst of all, Camunda has a hard-coded instanceof check, asserting the invoked Bean actually implements the interface like this:\nObject delegate = expression.getValue(execution); // ... } else if (delegate instanceof JavaDelegate) { Context.getProcessEngineConfiguration() .getDelegateInterceptor() .handleInvocation(new JavaDelegateInvocation((JavaDelegate) delegate, execution)); } // ... executeWithErrorPropagation(execution, callable); (see here)\nâ€¦ so itâ€™s not as simple as just leaving it away.\nMy next thought was to provide a @AroundConstruct interceptor. However these do not allow to replace (or rather wrap) the constructed object. You delegate the call, upon the inner-most delegate call the object is created and then passed upwards. You may invoke methods on the newly created object, but thereâ€™s no API to replace it.\nEnter CDI Extensions The plan is after all simple\ntake the @Named service task implementations, register them with CDI, but do not actually register them under the name\ncreate proxy classes, that implement JavaDelegate, register these under the original name\nwhen that proxy is actually invoked, create an instance of the actual implementation and delegate to it\nObserving ProcessAnnotatedType Letâ€™s assume our service tasks now implement the AcmeTask interface, then we can observe on ProcessAnnotatedType and check for instances of it like so:\n\u003cT\u003e void processAnnotatedType(@Observes final ProcessAnnotatedType\u003cT\u003e pat) { if (AcmeTask.class.isAssignableFrom( pat.getAnnotatedType().getJavaClass() ) { log.info(\"Processing annotated type \" + pat.getAnnotatedType().getJavaClass()); pat.setAnnotatedType(new AnnotatedTypeShadowNamedWrapper\u003c\u003e(pat.getAnnotatedType())); // pat.veto(); // Prevent CDI from registering it } } With pat.veto() we could keep the bean from being registered at all. Yet this is not what we want, since in the end we still want to be able to instantiate these beans later on â€“ and profit from the dependency injection functionality into these.\nInstead we just hide the @Named annotation from pat. The AnnotatedTypeShadowNamedWrapper is a lightweight wrapper, delegating all calls to the wrapped object, â€¦ just denying existence of that single annotation like so:\npublic static class AnnotatedTypeShadowNamedWrapper\u003cT\u003e implements AnnotatedType\u003cT\u003e { private final AnnotatedType\u003cT\u003e delegate; public AnnotatedTypeShadowNamedWrapper(final AnnotatedType\u003cT\u003e delegate) { this.delegate = delegate; } @Override public \u003cA extends Annotation\u003e A getAnnotation(final Class\u003cA\u003e annotationType) { if (annotationType == Named.class) { return null; } return delegate.getAnnotation(annotationType); } @Override public Set\u003cAnnotation\u003e getAnnotations() { final Set\u003cAnnotation\u003e annotations = new HashSet\u003c\u003e(delegate.getAnnotations()); annotations.removeIf(a -\u003e a.annotationType().equals(Named.class)); return annotations; } @Override public boolean isAnnotationPresent(final Class\u003c? extends Annotation\u003e annotationType) { if (annotationType == Named.class) { return false; } return delegate.isAnnotationPresent(annotationType); } // everything else is just passed through ... } Creating the Proxy Beans Now that weâ€™ve hidden the Named beans, we need to provide suitable replacements, that implement JavaDelegate and are named.\nTo achieve this, we need to add some bookkeeping to the observer method above, that tracks the registered name and class instance. Next we can observe the AfterBeanDiscovery event, which provides a means to register extra beans (one for each task), declaring its type, name and scope:\nvoid afterBeanDiscovery(@Observes final AfterBeanDiscovery abd, final BeanManager bm) { abd.addBean(new Bean\u003cJavaDelegate\u003e() { @Override public Class\u003c?\u003e getBeanClass() { return JavaDelegate.class; } @Override public Set\u003cAnnotation\u003e getQualifiers() { return Set.of(NamedLiteral.of(\"taskValidateStuff\")); } @Override public String getName() { return \"taskValidateStuff\"; } @Override public Class\u003c? extends Annotation\u003e getScope() { return Dependent.class; } â€¦ next we need to implement the create method, which must create an instance of JavaDelegate, every time the bean manager is asked for one. Since JavaDelegate is an interface, we can just use good old Proxy.newProxyInstance to get an instance and provide an InvocationHandler that waits for the execute call and delegates to our AcmeTask. There we can also add a wrapper abstracting process engine access.\n@SneakyThrows @Override public JavaDelegate create(final CreationalContext\u003cJavaDelegate\u003e ctx) { final var baseInstance = (AcmeTask) bm.getReference(bm.resolve(bm.getBeans(clazz)), clazz, ctx); return (JavaDelegate) Proxy.newProxyInstance(clazz.getClassLoader(), new Class[] { JavaDelegate.class }, (InvocationHandler) (proxy, method, args) -\u003e { log.info(\"Intercepted method: \" + method.getName()); if (\"execute\".equals(method.getName())) { // args[0] has the DelegateExecution baseInstance.execute( new DelegateExecutionWrapper( args[0] )); } return null; }); } ","wordCount":"723","inLanguage":"en","datePublished":"2025-06-19T00:00:00Z","dateModified":"2025-06-19T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://stefansiegl.de/2025/06/dependency-inversion-for-camunda-tasks/"},"publisher":{"@type":"Organization","name":"~stesie's musings","logo":{"@type":"ImageObject","url":"https://stefansiegl.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://stefansiegl.de/ accesskey=h title="~stesie's musings (Alt + H)">~stesie's musings</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://stefansiegl.de/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://stefansiegl.de/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://stefansiegl.de/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://stefansiegl.de/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Dependency Inversion for Camunda Tasks</h1><div class=post-meta>Status: ðŸŒ± Seedling&nbsp;Â·&nbsp;Planted:&nbsp;<span title='2025-06-19 00:00:00 +0000 UTC'>Jun 19, 2025</span>&nbsp;Â·&nbsp;4 min</div></header><div class=post-content><p>In Camunda Service Tasks can be implemented using so-called <em>delegate expressions</em>, which, in the context of CDI, resolve to <code>@Named</code> annotated beans.</p><p>This task class has to implement the <code>JavaDelegate</code> interface, which mandates a method named <code>execute</code>, which receives a single argument with a <code>DelegateExecution</code> instance. However there is the <em>Dependency Inversion Principle</em> (DIP), and this way our business code directly depends on two classes from Camunda. Can&rsquo;t we do better?</p><p>What about providing an abstraction over the variable scopes and an interface of our own, tagging all our service classes? And afterward have implementation that binds these interfaces.</p><p>First of all, Camunda has a hard-coded <code>instanceof</code> check, asserting the invoked Bean actually implements the interface like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>        Object delegate <span style=color:#f92672>=</span> expression.<span style=color:#a6e22e>getValue</span>(execution);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (delegate <span style=color:#66d9ef>instanceof</span> JavaDelegate) {
</span></span><span style=display:flex><span>          Context.<span style=color:#a6e22e>getProcessEngineConfiguration</span>()
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>getDelegateInterceptor</span>()
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>handleInvocation</span>(<span style=color:#66d9ef>new</span> JavaDelegateInvocation((JavaDelegate) delegate, execution));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span><span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    executeWithErrorPropagation(execution, callable);
</span></span></code></pre></div><p>(<a href=https://github.com/camunda/camunda-bpm-platform/blob/7.23.0/engine/src/main/java/org/camunda/bpm/engine/impl/bpmn/behavior/ServiceTaskDelegateExpressionActivityBehavior.java#L115>see here</a>)</p><p>&mldr; so it&rsquo;s not as simple as just leaving it away.</p><p>My next thought was to provide a <code>@AroundConstruct</code> interceptor. However these do <strong>not</strong> allow to replace (or rather wrap) the constructed object. You delegate the call, upon the inner-most delegate call the object is created and then passed upwards. You may invoke methods on the newly created object, but there&rsquo;s no API to replace it.</p><h2 id=enter-cdi-extensions>Enter CDI Extensions<a hidden class=anchor aria-hidden=true href=#enter-cdi-extensions>#</a></h2><p>The plan is after all simple</p><ul><li><p>take the <code>@Named</code> service task implementations, register them with CDI, but do <strong>not</strong> actually register them under the name</p></li><li><p>create proxy classes, that implement <code>JavaDelegate</code>, register these under the original name</p></li><li><p>when that proxy is actually invoked, create an instance of the actual implementation and delegate to it</p></li></ul><h3 id=observing-processannotatedtype>Observing ProcessAnnotatedType<a hidden class=anchor aria-hidden=true href=#observing-processannotatedtype>#</a></h3><p>Let&rsquo;s assume our service tasks now implement the <code>AcmeTask</code> interface, then we can <strong>observe</strong> on <code>ProcessAnnotatedType</code> and check for instances of it like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>        <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>processAnnotatedType</span>(<span style=color:#a6e22e>@Observes</span> <span style=color:#66d9ef>final</span> ProcessAnnotatedType<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> pat) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (AcmeTask.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>isAssignableFrom</span>( pat.<span style=color:#a6e22e>getAnnotatedType</span>().<span style=color:#a6e22e>getJavaClass</span>() ) {
</span></span><span style=display:flex><span>                        log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Processing annotated type &#34;</span> <span style=color:#f92672>+</span> pat.<span style=color:#a6e22e>getAnnotatedType</span>().<span style=color:#a6e22e>getJavaClass</span>());
</span></span><span style=display:flex><span>                        pat.<span style=color:#a6e22e>setAnnotatedType</span>(<span style=color:#66d9ef>new</span> AnnotatedTypeShadowNamedWrapper<span style=color:#f92672>&lt;&gt;</span>(pat.<span style=color:#a6e22e>getAnnotatedType</span>()));
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// pat.veto(); // Prevent CDI from registering it</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>With <code>pat.veto()</code> we could keep the bean from being registered at all. Yet this is not what we want, since in the end we still want to be able to instantiate these beans later on &ndash; and profit from the dependency injection functionality into these.</p><p>Instead we just hide the <code>@Named</code> annotation from <code>pat</code>. The <code>AnnotatedTypeShadowNamedWrapper</code> is a lightweight wrapper, delegating all calls to the wrapped object, &mldr; just denying existence of that single annotation like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AnnotatedTypeShadowNamedWrapper</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> AnnotatedType<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> AnnotatedType<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> delegate;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>AnnotatedTypeShadowNamedWrapper</span>(<span style=color:#66d9ef>final</span> AnnotatedType<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> delegate) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>delegate</span> <span style=color:#f92672>=</span> delegate;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>A <span style=color:#66d9ef>extends</span> Annotation<span style=color:#f92672>&gt;</span> A <span style=color:#a6e22e>getAnnotation</span>(<span style=color:#66d9ef>final</span> Class<span style=color:#f92672>&lt;</span>A<span style=color:#f92672>&gt;</span> annotationType) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (annotationType <span style=color:#f92672>==</span> Named.<span style=color:#a6e22e>class</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> delegate.<span style=color:#a6e22e>getAnnotation</span>(annotationType);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> Set<span style=color:#f92672>&lt;</span>Annotation<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getAnnotations</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Set<span style=color:#f92672>&lt;</span>Annotation<span style=color:#f92672>&gt;</span> annotations <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashSet<span style=color:#f92672>&lt;&gt;</span>(delegate.<span style=color:#a6e22e>getAnnotations</span>());
</span></span><span style=display:flex><span>    annotations.<span style=color:#a6e22e>removeIf</span>(a <span style=color:#f92672>-&gt;</span> a.<span style=color:#a6e22e>annotationType</span>().<span style=color:#a6e22e>equals</span>(Named.<span style=color:#a6e22e>class</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> annotations;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isAnnotationPresent</span>(<span style=color:#66d9ef>final</span> Class<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Annotation<span style=color:#f92672>&gt;</span> annotationType) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (annotationType <span style=color:#f92672>==</span> Named.<span style=color:#a6e22e>class</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> delegate.<span style=color:#a6e22e>isAnnotationPresent</span>(annotationType);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// everything else is just passed through ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=creating-the-proxy-beans>Creating the Proxy Beans<a hidden class=anchor aria-hidden=true href=#creating-the-proxy-beans>#</a></h2><p>Now that we&rsquo;ve hidden the Named beans, we need to provide suitable replacements, that implement <code>JavaDelegate</code> and are named.</p><p>To achieve this, we need to add some bookkeeping to the observer method above, that tracks the registered name and class instance. Next we can observe the <code>AfterBeanDiscovery</code> event, which provides a means to register extra beans (one for each task), declaring its type, name and scope:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>afterBeanDiscovery</span>(<span style=color:#a6e22e>@Observes</span> <span style=color:#66d9ef>final</span> AfterBeanDiscovery abd, <span style=color:#66d9ef>final</span> BeanManager bm) {
</span></span><span style=display:flex><span>  abd.<span style=color:#a6e22e>addBean</span>(<span style=color:#66d9ef>new</span> Bean<span style=color:#f92672>&lt;</span>JavaDelegate<span style=color:#f92672>&gt;</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Class<span style=color:#f92672>&lt;?&gt;</span> getBeanClass() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> JavaDelegate.<span style=color:#a6e22e>class</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Set<span style=color:#f92672>&lt;</span>Annotation<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getQualifiers</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> Set.<span style=color:#a6e22e>of</span>(NamedLiteral.<span style=color:#a6e22e>of</span>(<span style=color:#e6db74>&#34;taskValidateStuff&#34;</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;taskValidateStuff&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Class<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Annotation<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getScope</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> Dependent.<span style=color:#a6e22e>class</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>&mldr; next we need to implement the <code>create</code> method, which must create an instance of <code>JavaDelegate</code>, every time the bean manager is asked for one. Since <code>JavaDelegate</code> is an interface, we can just use good old <code>Proxy.newProxyInstance</code> to get an instance and provide an <code>InvocationHandler</code> that waits for the <code>execute</code> call and delegates to our <code>AcmeTask</code>. There we can also add a wrapper abstracting process engine access.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> JavaDelegate <span style=color:#a6e22e>create</span>(<span style=color:#66d9ef>final</span> CreationalContext<span style=color:#f92672>&lt;</span>JavaDelegate<span style=color:#f92672>&gt;</span> ctx) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>var</span> baseInstance <span style=color:#f92672>=</span> (AcmeTask) bm.<span style=color:#a6e22e>getReference</span>(bm.<span style=color:#a6e22e>resolve</span>(bm.<span style=color:#a6e22e>getBeans</span>(clazz)), clazz, ctx);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> (JavaDelegate) Proxy.<span style=color:#a6e22e>newProxyInstance</span>(clazz.<span style=color:#a6e22e>getClassLoader</span>(),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span> { JavaDelegate.<span style=color:#a6e22e>class</span> },
</span></span><span style=display:flex><span>        (InvocationHandler) (proxy, method, args) <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>          log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Intercepted method: &#34;</span> <span style=color:#f92672>+</span> method.<span style=color:#a6e22e>getName</span>());
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> (<span style=color:#e6db74>&#34;execute&#34;</span>.<span style=color:#a6e22e>equals</span>(method.<span style=color:#a6e22e>getName</span>())) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// args[0] has the DelegateExecution</span>
</span></span><span style=display:flex><span>            baseInstance.<span style=color:#a6e22e>execute</span>( <span style=color:#66d9ef>new</span> DelegateExecutionWrapper( args<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> ));
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://stefansiegl.de/tags/camunda/>Camunda</a></li><li><a href=https://stefansiegl.de/tags/dependency-inversion/>Dependency Inversion</a></li></ul></footer></article></main><footer class=footer><span>Â© 2025 Stefan Siegl Â· all content is <a href=https://creativecommons.org/licenses/by-sa/4.0/deed>CC-BY-SA</a> Â· <a href=https://www.swyx.io/digital-garden-tos#for-visitors>Terms of Service</a></span> Â·
<a href=/imprint>Imprint</a> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>