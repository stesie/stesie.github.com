<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Let's create a Coverage Analyzer, Part 1 | ~stesie's musings</title>
<meta name=keywords content="Java,Java Agents,Byte Code"><meta name=description content='Have you ever wondered what happens when you click on &ldquo;Run with Coverage&rdquo; in IntelliJ? Obviously it&rsquo;s running the tests, but how is it collecting the coverage information?
Let&rsquo;s create a simple Line Coverage Analyzer in and for Java ü•≥
First of all, let&rsquo;s write a simple example program (see GitHub)
package de.brokenpipe.dojo.undercovered.demo; public class Demo { public static void main(final String[] argv) { final String greeting = "Hello World"; bla(greeting); bla("to the blarg"); } private static void bla(final String greeting) { System.'><meta name=author content><link rel=canonical href=https://stefansiegl.de/2025/02/lets-create-a-coverage-analyzer-part-1/><link crossorigin=anonymous href=/assets/css/stylesheet.0c89971808195fcfba02b00128bb5209e165ff89d76c2f0d04eaefef9e1bd82a.css integrity="sha256-DImXGAgZX8+6ArABKLtSCeFl/4nXbC8NBOrv754b2Co=" rel="preload stylesheet" as=style><link rel=icon href=https://stefansiegl.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://stefansiegl.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://stefansiegl.de/favicon-32x32.png><link rel=apple-touch-icon href=https://stefansiegl.de/apple-touch-icon.png><link rel=mask-icon href=https://stefansiegl.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://stefansiegl.de/2025/02/lets-create-a-coverage-analyzer-part-1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Let's create a Coverage Analyzer, Part 1"><meta property="og:description" content='Have you ever wondered what happens when you click on &ldquo;Run with Coverage&rdquo; in IntelliJ? Obviously it&rsquo;s running the tests, but how is it collecting the coverage information?
Let&rsquo;s create a simple Line Coverage Analyzer in and for Java ü•≥
First of all, let&rsquo;s write a simple example program (see GitHub)
package de.brokenpipe.dojo.undercovered.demo; public class Demo { public static void main(final String[] argv) { final String greeting = "Hello World"; bla(greeting); bla("to the blarg"); } private static void bla(final String greeting) { System.'><meta property="og:type" content="article"><meta property="og:url" content="https://stefansiegl.de/2025/02/lets-create-a-coverage-analyzer-part-1/"><meta property="article:section" content="pages"><meta property="article:published_time" content="2025-02-17T00:00:00+00:00"><meta property="article:modified_time" content="2025-02-26T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Let's create a Coverage Analyzer, Part 1"><meta name=twitter:description content='Have you ever wondered what happens when you click on &ldquo;Run with Coverage&rdquo; in IntelliJ? Obviously it&rsquo;s running the tests, but how is it collecting the coverage information?
Let&rsquo;s create a simple Line Coverage Analyzer in and for Java ü•≥
First of all, let&rsquo;s write a simple example program (see GitHub)
package de.brokenpipe.dojo.undercovered.demo; public class Demo { public static void main(final String[] argv) { final String greeting = "Hello World"; bla(greeting); bla("to the blarg"); } private static void bla(final String greeting) { System.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Pages","item":"https://stefansiegl.de/pages/"},{"@type":"ListItem","position":2,"name":"Let's create a Coverage Analyzer, Part 1","item":"https://stefansiegl.de/2025/02/lets-create-a-coverage-analyzer-part-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Let's create a Coverage Analyzer, Part 1","name":"Let\u0027s create a Coverage Analyzer, Part 1","description":"Have you ever wondered what happens when you click on \u0026ldquo;Run with Coverage\u0026rdquo; in IntelliJ? Obviously it\u0026rsquo;s running the tests, but how is it collecting the coverage information?\nLet\u0026rsquo;s create a simple Line Coverage Analyzer in and for Java ü•≥\nFirst of all, let\u0026rsquo;s write a simple example program (see GitHub)\npackage de.brokenpipe.dojo.undercovered.demo; public class Demo { public static void main(final String[] argv) { final String greeting = \u0026#34;Hello World\u0026#34;; bla(greeting); bla(\u0026#34;to the blarg\u0026#34;); } private static void bla(final String greeting) { System.","keywords":["Java","Java Agents","Byte Code"],"articleBody":"Have you ever wondered what happens when you click on ‚ÄúRun with Coverage‚Äù in IntelliJ? Obviously it‚Äôs running the tests, but how is it collecting the coverage information?\nLet‚Äôs create a simple Line Coverage Analyzer in and for Java ü•≥\nFirst of all, let‚Äôs write a simple example program (see GitHub)\npackage de.brokenpipe.dojo.undercovered.demo; public class Demo { public static void main(final String[] argv) { final String greeting = \"Hello World\"; bla(greeting); bla(\"to the blarg\"); } private static void bla(final String greeting) { System.out.println(greeting); } } Coverage Collection Options In general coverage data can be collected in multiple ways. We could use profiling/debugging APIs or instrument the code. Instrumentation can be achieved on both, Source Code and Byte Code level. The latter can be done on-the-fly or ahead of time. The on-the-fly part can modify the Application Class Loader or use special APIs available to the Java Agent.\nSo what is Source Code Instrumentation? Let‚Äôs assume we would have a static tracking method like this:\npackage de.brokenpipe.dojo.undercovered.coverista.tracking; class Tracker { public static void track() { // TODO actually track the calling locations here } } ‚Ä¶ then we would just need to modify our source code like this:\npackage de.brokenpipe.dojo.undercovered.demo; import static de.brokenpipe.dojo.undercovered.coverista.tracking.Tracker.track; public class Demo { public static void main(final String[] argv) { track(); final String greeting = \"Hello World\"; track(); bla(greeting); track(); bla(\"to the blarg\"); } private static void bla(final String greeting) { track(); System.out.println(greeting); } } ‚Ä¶ and we should be done. Right!?\nObviously messing with the source code doesn‚Äôt feel nice. We‚Äôd need to re-compile everything, and after all we would need access to the source code in the first place. Also we shouldn‚Äôt overwrite the original source code, since the user likely doesn‚Äôt expect us to put all these track(); calls there.\nWe also would need to write a parser for Java Code, that understands which lines have a statement, so we can prepend our track(); call to these. Also considering statements spanning multiple lines.\nSo given that the Source Code is compiled to Byte Code anyways, how about instrumenting that instead?\nInstrumenting the Byte Code There are multiple tools, that you can use to inspect the Byte Code that‚Äôs stored within a .class file. IntelliJ itself has the ‚ÄúShow Bytecode‚Äù view action. On the command line there‚Äôs the javap tool, that‚Äôs part of the JDK. In it‚Äôs simplest form we can invoke it with the -c option, so it disassembles the byte code for us. Running javap -c demo/target/classes/de/brokenpipe/dojo/undercovered/demo/Demo.class should print this:\npublic static void main(java.lang.String[]); Code: 0: ldc #7 // String Hello World 2: astore_1 3: ldc #7 // String Hello World 5: invokestatic #9 // Method bla:(Ljava/lang/String;)V 8: ldc #15 // String to the blarg 10: invokestatic #9 // Method bla:(Ljava/lang/String;)V 13: return ‚ÑπÔ∏è You might wonder what these hash-numbers are!? These refer to the so-called constant pool.\n$ javap -v demo/target/classes/de/brokenpipe/dojo/undercovered/demo/Demo.class Constant pool: #1 = Methodref #2.#3 // java/lang/Object.\"\":()V #2 = Class #4 // java/lang/Object #3 = NameAndType #5:#6 // \"\":()V #4 = Utf8 java/lang/Object #5 = Utf8 #6 = Utf8 ()V #7 = String #8 // Hello World #8 = Utf8 Hello World #9 = Methodref #10.#11 // de/brokenpipe/dojo/undercovered/demo/Demo.bla:(Ljava/lang/String;)V #10 = Class #12 // de/brokenpipe/dojo/undercovered/demo/Demo #11 = NameAndType #13:#14 // bla:(Ljava/lang/String;)V #12 = Utf8 de/brokenpipe/dojo/undercovered/demo/Demo #13 = Utf8 bla #14 = Utf8 (Ljava/lang/String;)V So number 7 refers to a String, which refers to an Utf8 blob saying ‚ÄúHello World‚Äù. Likewise number 9 refers to a Methodref which itself refers to 10, 11 etc., which have the class name, method name and type information.\nWhen adding the -l option to the javap invocation, it should print the LineNumberTable as well:\nLineNumberTable: line 6: 0 line 8: 3 line 9: 8 line 11: 13 Equipped with that knowledge, we can now insert our track() method invocations at byte code offsets 0, 3, 8 and 13 ‚Ä¶ so we‚Äôll end up with something like this:\npublic static void main(java.lang.String[]); Code: 0: invokestatic #23 // Method de/brokenpipe/dojo/undercovered/coverista/Tracker.track:()V 3: ldc #7 // String Hello World 5: astore_1 6: invokestatic #23 // Method de/brokenpipe/dojo/undercovered/coverista/Tracker.track:()V 9: ldc #7 // String Hello World 11: invokestatic #9 // Method bla:(Ljava/lang/String;)V 14: invokestatic #23 // Method de/brokenpipe/dojo/undercovered/coverista/Tracker.track:()V 17: ldc #15 // String to the blarg 19: invokestatic #9 // Method bla:(Ljava/lang/String;)V 22: invokestatic #23 // Method de/brokenpipe/dojo/undercovered/coverista/Tracker.track:()V 25: return LineNumberTable: line 6: 0 line 8: 6 line 9: 14 line 11: 22 ‚Ä¶ and that‚Äôs it üéâ\nBut wait! After all, how can we actually hook into the byte code loading in the first place?\nJava Agents Since Java 5 there‚Äôs a feature called Java Agents, which are explained in the java.lang.instrument Package Docs. There the mechanism is described as follows:\nProvides services that allow Java programming language agents to instrument programs running on the JVM. The mechanism for instrumentation is modification of the byte-codes of methods.\nExactly what we need üòè\nIn contrast to the main method we define in normal application classes, for the agent we need to define a premain method, with the following signature:\npublic static void premain(String agentArgs, Instrumentation inst) ‚Ä¶ and as the name suggests, it‚Äôs executed before the actual main method. There might even be multiple agents, in which cases the premain methods are executed in order.\nFor the agent.jar file to actually work, we need to create a MANIFEST.MF file, declaring a property Premain-Class that points to the name of class, holding the premain method. Afterward we can pass the -javaagent:path/to/agent.jar argument to the java command line. The JRE should then already call premain.\nWhat we do in this premain method is actually up to us. We could mess with the class loader, or we can spin up some threads, monitoring the actual application. We can register shutdown hooks. Or we can just add a transformer, that performs the necessary byte code manipulations.\nOur premain method receives an instance of the Instrumentation class, which has this method:\nclass Instrumentation { /** * Registers the supplied transformer. * @param transformer the transformer to register */ void addTransformer(ClassFileTransformer transformer); } ‚Ä¶ and the ClassFileTransformer interface is very straight foward:\ninterface ClassFileTransformer { byte[] transform( Module module, ClassLoader loader, String className, Class\u003c?\u003e classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException } ‚Ä¶ we get a byte[] with the class file contents read from disk, and may return a modified byte[].\nSo we now know how to register a transformer, that can manipulate the byte code for us. Next step will be to actually come up with an implementation of that thing, that programmatically modifies the byte code array for us.\n-\u003e Let‚Äôs create a Coverage Analyzer, Part 2\n","wordCount":"1102","inLanguage":"en","datePublished":"2025-02-17T00:00:00Z","dateModified":"2025-02-26T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://stefansiegl.de/2025/02/lets-create-a-coverage-analyzer-part-1/"},"publisher":{"@type":"Organization","name":"~stesie's musings","logo":{"@type":"ImageObject","url":"https://stefansiegl.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://stefansiegl.de/ accesskey=h title="~stesie's musings (Alt + H)">~stesie's musings</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://stefansiegl.de/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://stefansiegl.de/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://stefansiegl.de/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://stefansiegl.de/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Let's create a Coverage Analyzer, Part 1</h1><div class=post-meta>Status: üå≥ Evergreen&nbsp;¬∑&nbsp;Planted:&nbsp;<span title='2025-02-17 00:00:00 +0000 UTC'>Feb 17, 2025</span>&nbsp;¬∑&nbsp;Last tended:&nbsp;<span title='2025-02-26 00:00:00 +0000 UTC'>Feb 26, 2025</span>&nbsp;¬∑&nbsp;6 min</div></header><div class=post-content><p>Have you ever wondered what happens when you click on &ldquo;Run with Coverage&rdquo; in IntelliJ? Obviously it&rsquo;s running the tests, but how is it collecting the coverage information?</p><p>Let&rsquo;s create a simple <em>Line</em> Coverage Analyzer in and for Java ü•≥</p><p>First of all, let&rsquo;s write a simple example program (see <a href=https://github.com/stesie/undercovered/blob/main/demo/src/main/java/de/brokenpipe/dojo/undercovered/demo/Demo.java>GitHub</a>)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> de.brokenpipe.dojo.undercovered.demo;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Demo</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>final</span> String<span style=color:#f92672>[]</span> argv) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>final</span> String greeting <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello World&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		bla(greeting);
</span></span><span style=display:flex><span>		bla(<span style=color:#e6db74>&#34;to the blarg&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>bla</span>(<span style=color:#66d9ef>final</span> String greeting) {
</span></span><span style=display:flex><span>		System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(greeting);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=coverage-collection-options>Coverage Collection Options<a hidden class=anchor aria-hidden=true href=#coverage-collection-options>#</a></h2><p>In general coverage data can be collected in multiple ways. We could use profiling/debugging APIs or instrument the code. Instrumentation can be achieved on both, Source Code and Byte Code level. The latter can be done on-the-fly or ahead of time. The on-the-fly part can modify the Application Class Loader or use special APIs available to the Java Agent.</p><p><img loading=lazy src=/assets/graphviz-instrumentation.png alt="The flowchart illustrates different approaches to code coverage, branching into &amp;ldquo;Runtime Profiling&amp;rdquo; and &amp;ldquo;Instrumentation,&amp;rdquo; with the latter further dividing into &amp;ldquo;Source Code&amp;rdquo; and &amp;ldquo;Byte Code&amp;rdquo; instrumentation. The &amp;ldquo;Byte Code&amp;rdquo; approach, highlighted in green, is categorized into &amp;ldquo;ahead of time&amp;rdquo; and &amp;ldquo;on-the-fly&amp;rdquo; modifications, where the latter further splits into &amp;ldquo;Class Loader&amp;rdquo; and &amp;ldquo;Java Agent,&amp;rdquo; also highlighted"></p><h2 id=so-what-is-source-code-instrumentation>So what is Source Code Instrumentation?<a hidden class=anchor aria-hidden=true href=#so-what-is-source-code-instrumentation>#</a></h2><p>Let&rsquo;s assume we would have a static tracking method like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> de.brokenpipe.dojo.undercovered.coverista.tracking;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Tracker</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>track</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TODO actually track the calling locations here</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr; then we would just need to modify our source code like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> de.brokenpipe.dojo.undercovered.demo;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import static</span> de.brokenpipe.dojo.undercovered.coverista.tracking.Tracker.track;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Demo</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>final</span> String<span style=color:#f92672>[]</span> argv) {
</span></span><span style=display:flex><span>		track(); <span style=color:#66d9ef>final</span> String greeting <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello World&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		track(); bla(greeting);
</span></span><span style=display:flex><span>		track(); bla(<span style=color:#e6db74>&#34;to the blarg&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>bla</span>(<span style=color:#66d9ef>final</span> String greeting) {
</span></span><span style=display:flex><span>		track(); System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(greeting);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr; and we should be done. Right!?</p><p>Obviously messing with the source code doesn&rsquo;t feel nice. We&rsquo;d need to re-compile everything, and after all we would need access to the source code in the first place. Also we shouldn&rsquo;t overwrite the original source code, since the user likely doesn&rsquo;t expect us to put all these <code>track();</code> calls there.</p><p>We also would need to write a parser for Java Code, that understands which lines have a statement, so we can prepend our <code>track();</code> call to these. Also considering statements spanning multiple lines.</p><p>So given that the Source Code is compiled to Byte Code anyways, how about instrumenting that instead?</p><h2 id=instrumenting-the-byte-code>Instrumenting the Byte Code<a hidden class=anchor aria-hidden=true href=#instrumenting-the-byte-code>#</a></h2><p>There are multiple tools, that you can use to inspect the Byte Code that&rsquo;s stored within a .class file. IntelliJ itself has the &ldquo;Show Bytecode&rdquo; view action. On the command line there&rsquo;s the <code>javap</code> tool, that&rsquo;s part of the JDK. In it&rsquo;s simplest form we can invoke it with the <code>-c</code> option, so it disassembles the byte code for us. Running <code>javap -c demo/target/classes/de/brokenpipe/dojo/undercovered/demo/Demo.class</code> should print this:</p><pre tabindex=0><code>  public static void main(java.lang.String[]);
    Code:
       0: ldc           #7                  // String Hello World
       2: astore_1
       3: ldc           #7                  // String Hello World
       5: invokestatic  #9                  // Method bla:(Ljava/lang/String;)V
       8: ldc           #15                 // String to the blarg
      10: invokestatic  #9                  // Method bla:(Ljava/lang/String;)V
      13: return
</code></pre><div class="admonition note"><div class=admonition-icon>‚ÑπÔ∏è</div><div class=admonition-body><p>You might wonder what these hash-numbers are!? These refer to the so-called <a href=https://blogs.oracle.com/javamagazine/post/java-class-file-constant-pool>constant pool</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ javap -v demo/target/classes/de/brokenpipe/dojo/undercovered/demo/Demo.class 
</span></span><span style=display:flex><span>Constant pool:
</span></span><span style=display:flex><span>   #1 = Methodref          #2.#3          // java/lang/Object.&#34;&lt;init&gt;&#34;:()V
</span></span><span style=display:flex><span>   #2 = Class              #4             // java/lang/Object
</span></span><span style=display:flex><span>   #3 = NameAndType        #5:#6          // &#34;&lt;init&gt;&#34;:()V
</span></span><span style=display:flex><span>   #4 = Utf8               java/lang/Object
</span></span><span style=display:flex><span>   #5 = Utf8               &lt;init&gt;
</span></span><span style=display:flex><span>   #6 = Utf8               ()V
</span></span><span style=display:flex><span>   #7 = String             #8             // Hello World
</span></span><span style=display:flex><span>   #8 = Utf8               Hello World
</span></span><span style=display:flex><span>   #9 = Methodref          #10.#11        // de/brokenpipe/dojo/undercovered/demo/Demo.bla:(Ljava/lang/String;)V
</span></span><span style=display:flex><span>  #10 = Class              #12            // de/brokenpipe/dojo/undercovered/demo/Demo
</span></span><span style=display:flex><span>  #11 = NameAndType        #13:#14        // bla:(Ljava/lang/String;)V
</span></span><span style=display:flex><span>  #12 = Utf8               de/brokenpipe/dojo/undercovered/demo/Demo
</span></span><span style=display:flex><span>  #13 = Utf8               bla
</span></span><span style=display:flex><span>  #14 = Utf8               (Ljava/lang/String;)V
</span></span></code></pre></div><p>So number 7 refers to a <code>String</code>, which refers to an <code>Utf8</code> blob saying &ldquo;Hello World&rdquo;. Likewise number 9 refers to a <code>Methodref</code> which itself refers to 10, 11 etc., which have the class name, method name and type information.</p></div></div><p>When adding the <code>-l</code> option to the <code>javap</code> invocation, it should print the <em>LineNumberTable</em> as well:</p><pre tabindex=0><code>    LineNumberTable:
      line 6: 0
      line 8: 3
      line 9: 8
      line 11: 13
</code></pre><p>Equipped with that knowledge, we can now insert our <code>track()</code> method invocations at byte code offsets 0, 3, 8 and 13 &mldr; so we&rsquo;ll end up with something like this:</p><pre tabindex=0><code>  public static void main(java.lang.String[]);
    Code:
       0: invokestatic  #23                 // Method de/brokenpipe/dojo/undercovered/coverista/Tracker.track:()V
       3: ldc           #7                  // String Hello World
       5: astore_1
       6: invokestatic  #23                 // Method de/brokenpipe/dojo/undercovered/coverista/Tracker.track:()V
       9: ldc           #7                  // String Hello World
      11: invokestatic  #9                  // Method bla:(Ljava/lang/String;)V
      14: invokestatic  #23                 // Method de/brokenpipe/dojo/undercovered/coverista/Tracker.track:()V
      17: ldc           #15                 // String to the blarg
      19: invokestatic  #9                  // Method bla:(Ljava/lang/String;)V
      22: invokestatic  #23                 // Method de/brokenpipe/dojo/undercovered/coverista/Tracker.track:()V
      25: return
    LineNumberTable:
      line 6: 0
      line 8: 6
      line 9: 14
      line 11: 22
</code></pre><p>&mldr; and that&rsquo;s it üéâ</p><p>But wait! After all, how can we actually hook into the byte code loading in the first place?</p><h2 id=java-agents>Java Agents<a hidden class=anchor aria-hidden=true href=#java-agents>#</a></h2><p>Since Java 5 there&rsquo;s a feature called Java Agents, which are explained in the <a href=https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html>java.lang.instrument Package Docs</a>. There the mechanism is described as follows:</p><blockquote><p>Provides services that allow Java programming language agents to instrument programs running on the JVM. The mechanism for instrumentation is modification of the byte-codes of methods.</p></blockquote><p>Exactly what we need üòè</p><p>In contrast to the <code>main</code> method we define in normal application classes, for the agent we need to define a <code>premain</code> method, with the following signature:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>premain</span>(String agentArgs, Instrumentation inst)
</span></span></code></pre></div><p>&mldr; and as the name suggests, it&rsquo;s executed <em>before</em> the actual <code>main</code> method. There might even be multiple agents, in which cases the <code>premain</code> methods are executed in order.</p><p>For the agent.jar file to actually work, we need to create a MANIFEST.MF file, declaring a property <code>Premain-Class</code> that points to the name of class, holding the <code>premain</code> method. Afterward we can pass the <code>-javaagent:path/to/agent.jar</code> argument to the <code>java</code> command line. The JRE should then already call <code>premain</code>.</p><p>What we do in this <code>premain</code> method is actually up to us. We could mess with the class loader, or we can spin up some threads, monitoring the actual application. We can register shutdown hooks. Or we can just add a transformer, that performs the necessary byte code manipulations.</p><p>Our <code>premain</code> method receives an instance of the <code>Instrumentation</code> class, which has this method:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Instrumentation</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Registers the supplied transformer.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param transformer          the transformer to register
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addTransformer</span>(ClassFileTransformer transformer);  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr; and the <code>ClassFileTransformer</code> interface is very straight foward:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ClassFileTransformer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>transform</span>(  Module              module,
</span></span><span style=display:flex><span>                ClassLoader         loader,
</span></span><span style=display:flex><span>                String              className,
</span></span><span style=display:flex><span>                Class<span style=color:#f92672>&lt;?&gt;</span>            classBeingRedefined,
</span></span><span style=display:flex><span>                ProtectionDomain    protectionDomain,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span>              classfileBuffer)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throws</span> IllegalClassFormatException
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr; we get a <code>byte[]</code> with the class file contents read from disk, and may return a modified <code>byte[]</code>.</p><p>So we now know how to register a transformer, that can manipulate the byte code for us. Next step will be to actually come up with an implementation of that thing, that programmatically modifies the byte code array for us.</p><p>-> <a href=https://stefansiegl.de/2025/02/lets-create-a-coverage-analyzer-part-2/>Let&rsquo;s create a Coverage Analyzer, Part 2</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://stefansiegl.de/tags/java/>Java</a></li><li><a href=https://stefansiegl.de/tags/java-agents/>Java Agents</a></li><li><a href=https://stefansiegl.de/tags/byte-code/>Byte Code</a></li></ul></footer></article></main><footer class=footer><span>¬© 2025 Stefan Siegl ¬∑ all content is <a href=https://creativecommons.org/licenses/by-sa/4.0/deed>CC-BY-SA</a> ¬∑ <a href=https://www.swyx.io/digital-garden-tos#for-visitors>Terms of Service</a></span> ¬∑
<a href=/imprint>Imprint</a> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>