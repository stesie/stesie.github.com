<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Let's create a Coverage Analyzer, Part 3 | ~stesie's musings</title>
<meta name=keywords content="Java,Java Agents,Byte Code"><meta name=description content="This is part three of my journey creating a Java (Line) Coverage Analyzer.
This time around we&rsquo;ll look into improving the very naive implementation created in part two. That one ended in a VerifyError and the message
Expecting a stackmap frame at branch target 41
So what is this branch target, and the stackmap frame that it&rsquo;s suddenly missing? To have an easier time inspecting the Byte Code, let&rsquo;s first create a little CLI version of our instrumentation code."><meta name=author content><link rel=canonical href=https://stefansiegl.de/2025/03/lets-create-a-coverage-analyzer-part-3/><link crossorigin=anonymous href=/assets/css/stylesheet.afb210dc38e6603228aff7827128220ab3093c72a2408955745ba993ab2977e6.css integrity="sha256-r7IQ3DjmYDIor/eCcSgiCrMJPHKiQIlVdFupk6spd+Y=" rel="preload stylesheet" as=style><link rel=icon href=https://stefansiegl.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://stefansiegl.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://stefansiegl.de/favicon-32x32.png><link rel=apple-touch-icon href=https://stefansiegl.de/apple-touch-icon.png><link rel=mask-icon href=https://stefansiegl.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://stefansiegl.de/2025/03/lets-create-a-coverage-analyzer-part-3/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Let's create a Coverage Analyzer, Part 3"><meta property="og:description" content="This is part three of my journey creating a Java (Line) Coverage Analyzer.
This time around we&rsquo;ll look into improving the very naive implementation created in part two. That one ended in a VerifyError and the message
Expecting a stackmap frame at branch target 41
So what is this branch target, and the stackmap frame that it&rsquo;s suddenly missing? To have an easier time inspecting the Byte Code, let&rsquo;s first create a little CLI version of our instrumentation code."><meta property="og:type" content="article"><meta property="og:url" content="https://stefansiegl.de/2025/03/lets-create-a-coverage-analyzer-part-3/"><meta property="article:section" content="pages"><meta property="article:published_time" content="2025-03-01T11:00:00+00:00"><meta property="article:modified_time" content="2025-03-01T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Let's create a Coverage Analyzer, Part 3"><meta name=twitter:description content="This is part three of my journey creating a Java (Line) Coverage Analyzer.
This time around we&rsquo;ll look into improving the very naive implementation created in part two. That one ended in a VerifyError and the message
Expecting a stackmap frame at branch target 41
So what is this branch target, and the stackmap frame that it&rsquo;s suddenly missing? To have an easier time inspecting the Byte Code, let&rsquo;s first create a little CLI version of our instrumentation code."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Pages","item":"https://stefansiegl.de/pages/"},{"@type":"ListItem","position":2,"name":"Let's create a Coverage Analyzer, Part 3","item":"https://stefansiegl.de/2025/03/lets-create-a-coverage-analyzer-part-3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Let's create a Coverage Analyzer, Part 3","name":"Let\u0027s create a Coverage Analyzer, Part 3","description":"This is part three of my journey creating a Java (Line) Coverage Analyzer.\nThis time around we\u0026rsquo;ll look into improving the very naive implementation created in part two. That one ended in a VerifyError and the message\nExpecting a stackmap frame at branch target 41\nSo what is this branch target, and the stackmap frame that it\u0026rsquo;s suddenly missing? To have an easier time inspecting the Byte Code, let\u0026rsquo;s first create a little CLI version of our instrumentation code.","keywords":["Java","Java Agents","Byte Code"],"articleBody":"This is part three of my journey creating a Java (Line) Coverage Analyzer.\nThis time around we’ll look into improving the very naive implementation created in part two. That one ended in a VerifyError and the message\nExpecting a stackmap frame at branch target 41\nSo what is this branch target, and the stackmap frame that it’s suddenly missing? To have an easier time inspecting the Byte Code, let’s first create a little CLI version of our instrumentation code. It shall just receive two file/path names, an input class file and a output location. Given the design of our Instrumenter class that’s very easy to do:\npublic class Coverista { public static void main(final String[] argv) { if (argv.length != 2) { System.err.println(\"expected two command arguments, path to input file + path to output file\"); System.exit(1); } final var result = new Instrumenter().instrumentClass(argv[0]); try (final var outputStream = new FileOutputStream(argv[1])) { outputStream.write(result); } catch (final IOException ex) { throw new RuntimeException(\"unable to write to file: \" + argv[1], ex); } } } Next we can just run that tool:\n$ java -cp coverista/target/classes:$HOME/.m2/repository/org/ow2/asm/asm/9.6/asm-9.6.jar de.brokenpipe.dojo.undercovered.coverista.Coverista demo/target/classes/de/brokenpipe/dojo/undercovered/demo/Demo2.class Demo2.instrumented.class With the instrumented byte code now stored to Demo2.instrumented.class, we can now call javap and check what was generated: javap -v Demo2.instrumented.class. That should output (among much other stuff):\npublic static void main(java.lang.String[]); Code: 17: iconst_0 18: istore_2 19: iload_2 20: iconst_3 21: if_icmpge 41 [...] 32: invokestatic #17 // Method de/brokenpipe/dojo/undercovered/coverista/Tracker.track:()V 35: iinc 2, 1 38: goto 19 41: invokestatic #17 // Method de/brokenpipe/dojo/undercovered/coverista/Tracker.track:()V 44: invokedynamic #52, 0 // InvokeDynamic #0:get:()Ljava/util/function/Supplier; 49: astore_2 [...] StackMapTable: number_of_entries = 2 frame_type = 253 /* append */ offset_delta = 19 locals = [ class java/lang/String, int ] frame_type = 250 /* chop */ offset_delta = 24 At byte code locations 17 \u0026 18 we see the initialization of our for-loop. The compiler obviously assigned variable slot 2 to our i variable, then first pushes the constant int 0 to the stack, before saving it to that slot. At locations 19, 20 and 21 we find the condition part of the for-loop. It first loads variable slot 2, then also pushes the upper bound value (3) and finally uses the if_icmpge instruction to conditionally jump to location 41, if the loop’s condition no longer holds. Last but not least in location 35 it’s incrementing the variable by one, prior to the unconditional branch (goto instruction) to location 19 … where it would re-evaluate the loop’s condition.\nStack Map Tables See the spec for more details. But in short it’s mandatory, that for each and every jump destination (be it conditional or unconditional branches, be it catch blocks) there must be an entry in the StackMapTable, that the Byte Code Verifier can use to verify proper condition of the stack.\nThe offset_delta property of the entries is defined interestingly: In order to make sure, that the entries are properly ordered, and there are no duplicate entries for the same location, they defined offset_delta to be relative. The value of the first frame is absolute after all. The second frame applies to the location of the first frame plus given offset_delta plus one.\nSo in our case,\nthe first entry targets offset 19\nthe second entry targets offset 19 + 24 + 1 = 44\nHowever at location 44 there is the invokedynamik opcode, and it’s clearly not the branch target of the if_icmpge, … which goes to 41. Let’s briefly compare this to the not instrumented Byte Code.\n$ javap -v demo/target/classes/de/brokenpipe/dojo/undercovered/demo/Demo2.class public static void main(java.lang.String[]); [...] 8: iconst_0 9: istore_2 10: iload_2 11: iconst_3 12: if_icmpge 26 [... 20: iinc 2, 1 23: goto 10 26: invokedynamic #17, 0 // InvokeDynamic #0:get:()Ljava/util/function/Supplier; 31: astore_2 [... StackMapTable: number_of_entries = 2 frame_type = 253 /* append */ offset_delta = 10 locals = [ class java/lang/String, int ] frame_type = 250 /* chop */ offset_delta = 15 Here the stack map table targets\nfirst entry offset = 10\nsecond entry offset = 10 + 15 + 1 = 26\n… which perfectly matches the target locations of both branch opcodes. So to put it differently: the way we currently instrument the code using ASM breaks the stack map table 😿\nFor the byte code location in question (i.e. the invokedynamic opcode at location 26) ASM triggers the visitor three times (in order)\nvisitLineNumber\nvisitFrame\nvisitInvokeDynamicInsn\n… genereally, the visitLineNumber is invoked on every line number label. The visitFrame is only called if there is a stack map frame associated with that location (at location 26 that’s the case). And afterward one of the various instruction visitor methods is invoked (but there are many).\nIf visitFrame is invoked (and delegated to the writer), it writes a stack map table entry for the current offset. And since we currently (unconditionally) write our tracker invocation from the visitLineNumber method, the offset will increment prior to the visitFrame. Which is why we observe visitFrame writing the wrong offset.\nThe problem is, that when visitLineNumber is called, we do not yet know whether visitFrame will be called, and there’s no way for us to find out. But we mustn’t write the new instruction in visitLineNumber if a frame must exist for that location. So we have two options:\neither we process the file in two passes: first time we “learn” which line numbers have a frame, next time around we know whether we must instrument from visitLineNumber or from visitFrame\nalternatively we couldn’t instrument from neither visitLineNumber nor visitFrame, but from each and every of the other visitor methods (but then don’t need a second pass)\nIf this wouldn’t be a learning project the decision would be simple: why a second pass, if we can do without it? However since this is a learning project and I strive for a clear implementation I go with option 1. Let’s do two passes, and conditionally instrument from either visitLineNumber or visitFrame.\nSo let’s create two MethodVisitor implementations. The first one just walking the class and telling a simple collector class, which line numbers have a stack map table entry:\npublic class LabelCollectingMethodVisitor extends MethodVisitor { private final JumpLabelCollector jumpLabelCollector; private Integer lastLineNumber = null; //... @Override public void visitLineNumber(final int line, final Label start) { super.visitLineNumber(line, start); lastLineNumber = Integer.valueOf(line); } @Override public void visitFrame(final int type, final int numLocal, final Object[] local, final int numStack, final Object[] stack) { super.visitFrame(type, numLocal, local, numStack, stack); jumpLabelCollector.accept(lastLineNumber); } } … in visitLineNumber we just keep the number. And in visitFrame we potentially pass it to the collector class.\nThe second MethodVisitor could then look like this:\npublic class InstrumentingMethodVisitor extends MethodVisitor { private final Set\u003cInteger\u003e jumpLabels; private Integer currentLineNumber = null; @Override public void visitLineNumber(final int line, final Label start) { currentLineNumber = Integer.valueOf(line); super.visitLineNumber(line, start); if (!jumpLabels.contains(currentLineNumber)) { instrument(currentLineNumber); } } @Override public void visitFrame(final int type, final int numLocal, final Object[] local, final int numStack, final Object[] stack) { super.visitFrame(type, numLocal, local, numStack, stack); if (jumpLabels.contains(currentLineNumber)) { instrument(currentLineNumber); } } } ℹ️ If you’d like to follow along, the undercovered GitHub repository has all the source code. Optimizing the Tracker My first naive implementation of Tracker just relied on Thread.currentThread().getStackTrace() calls to extract the name of the calling class as well as the current line number. Obviously that works, but is very inefficient. Especially given that we now have the currentLineNumber variable anyways … and the name of the class is known as well.\nTherefore let’s change the signature of Tracker#track to:\npublic class Tracker { public static void track(final String callingClass, final int line) { log.finer(\"hit \" + callingClass + \":\" + line); } } … obviously we have to adapt our instrumentation code accordingly. So far we set the descriptor to ()V, which means no arguments and returning void. The updated descriptor is (Ljava/lang/String;I)V. First argument is an object (L) of java.lang.String type, next argument is of int (I) type. Return type is still void (V).\nAnd prior to our invokestatic opcode we now have to push two frames onto the stack. First the class name (a string constant), using the ldc opcode. For the line number we have multiple options. For line numbers in the byte range (\u003c= 127) we can use the bipush opcode. For line numbers in the short range (\u003c= 32767) we can use the sipush opcode. Above that we need to resort back to constants (ldc again). But let’s hope that this never happens…\nSo our instrument method now looks like this:\npublic class InstrumentingMethodVisitor extends MethodVisitor { private final String className; private void instrument(final Integer line) { log.finer(\"instrument line: \" + line); super.visitLdcInsn(className); push(line); super.visitMethodInsn(Opcodes.INVOKESTATIC, \"de/brokenpipe/dojo/undercovered/coverista/tracking/Tracker\", \"track\", \"(Ljava/lang/String;I)V\", false); } private void push(final Integer value) { if (value.intValue() \u003c= Byte.MAX_VALUE) { super.visitIntInsn(Opcodes.BIPUSH, value.intValue()); } else if (value.intValue() \u003c= Short.MAX_VALUE) { super.visitIntInsn(Opcodes.SIPUSH, value.intValue()); } else { super.visitLdcInsn(value); } } } Again: VerifyError Our beloved VerifyError is back 😡\nError: Unable to initialize main class de.brokenpipe.dojo.undercovered.demo.Demo Caused by: java.lang.VerifyError: Operand stack overflow Exception Details: Location: de/brokenpipe/dojo/undercovered/demo/Demo.()V @2: bipush Reason: Exceeded max stack size. Current Frame: bci: @2 flags: { flagThisUninit } locals: { uninitializedThis } stack: { 'java/lang/String' } Bytecode: 0000000: 1208 1003 b800 0e2a b700 10b1 … this time with a different message. And the reason is pretty clear: Exceeded max stack size.\nChecking back on the javap -v output:\npublic static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: (0x0009) ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=2, args_size=1 … it says that the maximum stack size is 1. Obviously that already is in contrast to the two values we push to the stack. To fix this, we actually have two options\nwe can ask ASM to calculate the maximum stack size and update it accordingly (to do so, we would just have to instantiate the class writer with COMPUTE_MAX flag like this: new ClassWriter(ClassWriter.COMPUTE_MAXS))\nwe can modify the number on our own, and (in this simple case) just add 2\nFor real projects the former option would definitely be nicer. Especially since the second option easily leads to some waste. Our track calls likely don’t happen with the stack at its maximum size. But let’s neglect the couple of bytes potentially wasted, and override the visitMaxs method as well:\n@Override public void visitMaxs(final int maxStack, final int maxLocals) { super.visitMaxs(maxStack + 2, maxLocals); } … with that fixed, do we finally have the code necessary to track and that’s not immediately crashing after some first simple examples?\nLet’s create a Coverage Analyzer, Part 4 follows up on this implementation.\n","wordCount":"1746","inLanguage":"en","datePublished":"2025-03-01T11:00:00Z","dateModified":"2025-03-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://stefansiegl.de/2025/03/lets-create-a-coverage-analyzer-part-3/"},"publisher":{"@type":"Organization","name":"~stesie's musings","logo":{"@type":"ImageObject","url":"https://stefansiegl.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://stefansiegl.de/ accesskey=h title="~stesie's musings (Alt + H)">~stesie's musings</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://stefansiegl.de/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://stefansiegl.de/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://stefansiegl.de/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://stefansiegl.de/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Let's create a Coverage Analyzer, Part 3</h1><div class=post-meta>Status: 🌱 Seedling&nbsp;·&nbsp;Planted:&nbsp;<span title='2025-03-01 11:00:00 +0000 UTC'>Mar 1, 2025</span>&nbsp;·&nbsp;Last tended:&nbsp;<span title='2025-03-01 00:00:00 +0000 UTC'>Mar 1, 2025</span>&nbsp;·&nbsp;9 min</div></header><div class=post-content><p>This is part three of my journey creating a Java (Line) Coverage Analyzer.</p><p>This time around we&rsquo;ll look into improving the <a href=https://stefansiegl.de/2025/02/lets-create-a-coverage-analyzer-part-2/>very naive implementation created in part two</a>. That one ended in a <code>VerifyError</code> and the message</p><blockquote><p>Expecting a stackmap frame at branch target 41</p></blockquote><p>So what is this branch target, and the stackmap frame that it&rsquo;s suddenly missing? To have an easier time inspecting the Byte Code, let&rsquo;s first create a little CLI version of our instrumentation code. It shall just receive two file/path names, an input class file and a output location. Given the design of our <em>Instrumenter</em> class that&rsquo;s very easy to do:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Coverista</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>final</span> String<span style=color:#f92672>[]</span> argv) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (argv.<span style=color:#a6e22e>length</span> <span style=color:#f92672>!=</span> 2) {
</span></span><span style=display:flex><span>			System.<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;expected two command arguments, path to input file + path to output file&#34;</span>);
</span></span><span style=display:flex><span>			System.<span style=color:#a6e22e>exit</span>(1);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>final</span> <span style=color:#66d9ef>var</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Instrumenter().<span style=color:#a6e22e>instrumentClass</span>(argv<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>try</span> (<span style=color:#66d9ef>final</span> <span style=color:#66d9ef>var</span> outputStream <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FileOutputStream(argv<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>)) {
</span></span><span style=display:flex><span>			outputStream.<span style=color:#a6e22e>write</span>(result);
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>catch</span> (<span style=color:#66d9ef>final</span> IOException ex) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(<span style=color:#e6db74>&#34;unable to write to file: &#34;</span> <span style=color:#f92672>+</span> argv<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>, ex);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next we can just run that tool:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ java -cp coverista/target/classes:$HOME/.m2/repository/org/ow2/asm/asm/9.6/asm-9.6.jar de.brokenpipe.dojo.undercovered.coverista.Coverista demo/target/classes/de/brokenpipe/dojo/undercovered/demo/Demo2.class Demo2.instrumented.class
</span></span></code></pre></div><p>With the instrumented byte code now stored to <em>Demo2.instrumented.class</em>, we can now call <em>javap</em> and check what was generated: <code>javap -v Demo2.instrumented.class</code>. That should output (among much other stuff):</p><pre tabindex=0><code>  public static void main(java.lang.String[]);
    Code:
        17: iconst_0
        18: istore_2
        19: iload_2
        20: iconst_3
        21: if_icmpge     41
[...]
        32: invokestatic  #17                 // Method de/brokenpipe/dojo/undercovered/coverista/Tracker.track:()V
        35: iinc          2, 1
        38: goto          19
        41: invokestatic  #17                 // Method de/brokenpipe/dojo/undercovered/coverista/Tracker.track:()V
        44: invokedynamic #52,  0             // InvokeDynamic #0:get:()Ljava/util/function/Supplier;
        49: astore_2
[...]
      StackMapTable: number_of_entries = 2
        frame_type = 253 /* append */
          offset_delta = 19
          locals = [ class java/lang/String, int ]
        frame_type = 250 /* chop */
          offset_delta = 24
</code></pre><p>At byte code locations 17 & 18 we see the initialization of our for-loop. The compiler obviously assigned variable slot 2 to our <code>i</code> variable, then first pushes the constant int 0 to the stack, before saving it to that slot. At locations 19, 20 and 21 we find the condition part of the for-loop. It first loads variable slot 2, then also pushes the upper bound value (3) and finally uses the <code>if_icmpge</code> instruction to conditionally jump to location 41, if the loop&rsquo;s condition no longer holds. Last but not least in location 35 it&rsquo;s incrementing the variable by one, prior to the unconditional branch (goto instruction) to location 19 &mldr; where it would re-evaluate the loop&rsquo;s condition.</p><div class=important><h3 id=stack-map-tables>Stack Map Tables<a hidden class=anchor aria-hidden=true href=#stack-map-tables>#</a></h3><p><a href=https://docs.oracle.com/javase/specs/jvms/se23/html/jvms-4.html#jvms-4.7.4>See the spec for more details</a>. But in short it&rsquo;s mandatory, that for each and every jump destination (be it conditional or unconditional branches, be it catch blocks) there must be an entry in the <code>StackMapTable</code>, that the Byte Code Verifier can use to verify proper condition of the stack.</p><p>The <code>offset_delta</code> property of the entries is defined interestingly: In order to make sure, that the entries are properly ordered, and there are no duplicate entries for the same location, they defined <code>offset_delta</code> to be relative. The value of the first frame is absolute after all. The second frame applies to the location of the first frame plus given <code>offset_delta</code> <strong>plus one</strong>.</p></div><p>So in our case,</p><ul><li><p>the first entry targets offset 19</p></li><li><p>the second entry targets offset 19 + 24 + 1 = 44</p></li></ul><p>However at location 44 there is the <code>invokedynamik</code> opcode, and it&rsquo;s clearly not the branch target of the <code>if_icmpge</code>, &mldr; which goes to 41. Let&rsquo;s briefly compare this to the not instrumented Byte Code.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ javap -v demo/target/classes/de/brokenpipe/dojo/undercovered/demo/Demo2.class
</span></span><span style=display:flex><span>  public static void main(java.lang.String[]);
</span></span><span style=display:flex><span>[...]
</span></span><span style=display:flex><span>         8: iconst_0
</span></span><span style=display:flex><span>         9: istore_2
</span></span><span style=display:flex><span>        10: iload_2
</span></span><span style=display:flex><span>        11: iconst_3
</span></span><span style=display:flex><span>        12: if_icmpge     26
</span></span><span style=display:flex><span>[...
</span></span><span style=display:flex><span>        20: iinc          2, 1
</span></span><span style=display:flex><span>        23: goto          10
</span></span><span style=display:flex><span>        26: invokedynamic #17,  0             // InvokeDynamic #0:get:()Ljava/util/function/Supplier;
</span></span><span style=display:flex><span>        31: astore_2
</span></span><span style=display:flex><span>[...
</span></span><span style=display:flex><span>      StackMapTable: number_of_entries = 2
</span></span><span style=display:flex><span>        frame_type = 253 /* append */
</span></span><span style=display:flex><span>          offset_delta = 10
</span></span><span style=display:flex><span>          locals = [ class java/lang/String, int ]
</span></span><span style=display:flex><span>        frame_type = 250 /* chop */
</span></span><span style=display:flex><span>          offset_delta = 15
</span></span></code></pre></div><p>Here the stack map table targets</p><ul><li><p>first entry offset = 10</p></li><li><p>second entry offset = 10 + 15 + 1 = 26</p></li></ul><p>&mldr; which perfectly matches the target locations of both branch opcodes. So to put it differently: the way we currently instrument the code using ASM breaks the stack map table 😿</p><p>For the byte code location in question (i.e. the <code>invokedynamic</code> opcode at location 26) ASM triggers the visitor three times (in order)</p><ul><li><p>visitLineNumber</p></li><li><p>visitFrame</p></li><li><p>visitInvokeDynamicInsn</p></li></ul><p>&mldr; genereally, the <code>visitLineNumber</code> is invoked on every line number label. The <code>visitFrame</code> is only called if there is a stack map frame associated with that location (at location 26 that&rsquo;s the case). And afterward one of the various instruction visitor methods is invoked (but there are many).</p><p>If <code>visitFrame</code> is invoked (and delegated to the writer), it writes a stack map table entry for the current offset. And since we currently (unconditionally) write our tracker invocation from the <code>visitLineNumber</code> method, the offset will increment prior to the <code>visitFrame</code>. Which is why we observe <code>visitFrame</code> writing the wrong offset.</p><p>The problem is, that when <code>visitLineNumber</code> is called, we do not yet know whether <code>visitFrame</code> will be called, and there&rsquo;s no way for us to find out. But we mustn&rsquo;t write the new instruction in <code>visitLineNumber</code> if a frame must exist for that location. So we have two options:</p><ul><li><p>either we process the file in two passes: first time we &ldquo;learn&rdquo; which line numbers have a frame, next time around we know whether we must instrument from <code>visitLineNumber</code> or from <code>visitFrame</code></p></li><li><p>alternatively we couldn&rsquo;t instrument from neither <code>visitLineNumber</code> nor <code>visitFrame</code>, but from each and every of the other visitor methods (but then don&rsquo;t need a second pass)</p></li></ul><p>If this wouldn&rsquo;t be a learning project the decision would be simple: why a second pass, if we can do without it? However since this is a learning project and I strive for a clear implementation I go with option 1. Let&rsquo;s do two passes, and conditionally instrument from either <code>visitLineNumber</code> or <code>visitFrame</code>.</p><p>So let&rsquo;s create two <code>MethodVisitor</code> implementations. The first one just walking the class and telling a simple collector class, which line numbers have a stack map table entry:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LabelCollectingMethodVisitor</span> <span style=color:#66d9ef>extends</span> MethodVisitor {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> JumpLabelCollector jumpLabelCollector;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> Integer lastLineNumber <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>//...</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>visitLineNumber</span>(<span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> line, <span style=color:#66d9ef>final</span> Label start) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>visitLineNumber</span>(line, start);
</span></span><span style=display:flex><span>		lastLineNumber <span style=color:#f92672>=</span> Integer.<span style=color:#a6e22e>valueOf</span>(line);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>visitFrame</span>(<span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> type, <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> numLocal, <span style=color:#66d9ef>final</span> Object<span style=color:#f92672>[]</span> local, <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> numStack, <span style=color:#66d9ef>final</span> Object<span style=color:#f92672>[]</span> stack) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>visitFrame</span>(type, numLocal, local, numStack, stack);
</span></span><span style=display:flex><span>		jumpLabelCollector.<span style=color:#a6e22e>accept</span>(lastLineNumber);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr; in <code>visitLineNumber</code> we just keep the number. And in <code>visitFrame</code> we potentially pass it to the collector class.</p><p>The second <code>MethodVisitor</code> could then look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>InstrumentingMethodVisitor</span> <span style=color:#66d9ef>extends</span> MethodVisitor {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Set<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> jumpLabels;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> Integer currentLineNumber <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>visitLineNumber</span>(<span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> line, <span style=color:#66d9ef>final</span> Label start) {
</span></span><span style=display:flex><span>		currentLineNumber <span style=color:#f92672>=</span> Integer.<span style=color:#a6e22e>valueOf</span>(line);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>visitLineNumber</span>(line, start);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>jumpLabels.<span style=color:#a6e22e>contains</span>(currentLineNumber)) {
</span></span><span style=display:flex><span>			instrument(currentLineNumber);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>visitFrame</span>(<span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> type, <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> numLocal, <span style=color:#66d9ef>final</span> Object<span style=color:#f92672>[]</span> local, <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> numStack,
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>final</span> Object<span style=color:#f92672>[]</span> stack) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>visitFrame</span>(type, numLocal, local, numStack, stack);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (jumpLabels.<span style=color:#a6e22e>contains</span>(currentLineNumber)) {
</span></span><span style=display:flex><span>			instrument(currentLineNumber);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="admonition note"><div class=admonition-icon>ℹ️</div><div class=admonition-body>If you&rsquo;d like to follow along, <a href=https://github.com/stesie/undercovered>the undercovered GitHub repository has all the source code</a>.</div></div><h2 id=optimizing-the-tracker>Optimizing the Tracker<a hidden class=anchor aria-hidden=true href=#optimizing-the-tracker>#</a></h2><p>My first naive implementation of <code>Tracker</code> just relied on <code>Thread.currentThread().getStackTrace()</code> calls to extract the name of the calling class as well as the current line number. Obviously that works, but is very inefficient. Especially given that we now have the <code>currentLineNumber</code> variable anyways &mldr; and the name of the class is known as well.</p><p>Therefore let&rsquo;s change the signature of <code>Tracker#track</code> to:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Tracker</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>track</span>(<span style=color:#66d9ef>final</span> String callingClass, <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> line) {
</span></span><span style=display:flex><span>		log.<span style=color:#a6e22e>finer</span>(<span style=color:#e6db74>&#34;hit &#34;</span> <span style=color:#f92672>+</span> callingClass <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;:&#34;</span> <span style=color:#f92672>+</span> line);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr; obviously we have to adapt our instrumentation code accordingly. So far we set the descriptor to <code>()V</code>, which means no arguments and returning void. The updated descriptor is <code>(Ljava/lang/String;I)V</code>. First argument is an object (<code>L</code>) of <code>java.lang.String</code> type, next argument is of <code>int</code> (<code>I</code>) type. Return type is still void (<code>V</code>).</p><p>And prior to our <code>invokestatic</code> opcode we now have to push two frames onto the stack. First the class name (a string constant), using the <code>ldc</code> opcode. For the line number we have multiple options. For line numbers in the byte range (&lt;= 127) we can use the <code>bipush</code> opcode. For line numbers in the short range (&lt;= 32767) we can use the <code>sipush</code> opcode. Above that we need to resort back to constants (<code>ldc</code> again). But let&rsquo;s hope that this never happens&mldr;</p><p>So our <code>instrument</code> method now looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>InstrumentingMethodVisitor</span> <span style=color:#66d9ef>extends</span> MethodVisitor {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> String className;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>instrument</span>(<span style=color:#66d9ef>final</span> Integer line) {
</span></span><span style=display:flex><span>		log.<span style=color:#a6e22e>finer</span>(<span style=color:#e6db74>&#34;instrument line: &#34;</span> <span style=color:#f92672>+</span> line);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>visitLdcInsn</span>(className);
</span></span><span style=display:flex><span>		push(line);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>visitMethodInsn</span>(Opcodes.<span style=color:#a6e22e>INVOKESTATIC</span>, <span style=color:#e6db74>&#34;de/brokenpipe/dojo/undercovered/coverista/tracking/Tracker&#34;</span>,
</span></span><span style=display:flex><span>				<span style=color:#e6db74>&#34;track&#34;</span>, <span style=color:#e6db74>&#34;(Ljava/lang/String;I)V&#34;</span>, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>push</span>(<span style=color:#66d9ef>final</span> Integer value) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (value.<span style=color:#a6e22e>intValue</span>() <span style=color:#f92672>&lt;=</span> Byte.<span style=color:#a6e22e>MAX_VALUE</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>visitIntInsn</span>(Opcodes.<span style=color:#a6e22e>BIPUSH</span>, value.<span style=color:#a6e22e>intValue</span>());
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (value.<span style=color:#a6e22e>intValue</span>() <span style=color:#f92672>&lt;=</span> Short.<span style=color:#a6e22e>MAX_VALUE</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>visitIntInsn</span>(Opcodes.<span style=color:#a6e22e>SIPUSH</span>, value.<span style=color:#a6e22e>intValue</span>());
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>visitLdcInsn</span>(value);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=again-verifyerror>Again: VerifyError<a hidden class=anchor aria-hidden=true href=#again-verifyerror>#</a></h3><p>Our beloved <code>VerifyError</code> is back 😡</p><pre tabindex=0><code>Error: Unable to initialize main class de.brokenpipe.dojo.undercovered.demo.Demo
Caused by: java.lang.VerifyError: Operand stack overflow
Exception Details:
  Location:
    de/brokenpipe/dojo/undercovered/demo/Demo.&lt;init&gt;()V @2: bipush
  Reason:
    Exceeded max stack size.
  Current Frame:
    bci: @2
    flags: { flagThisUninit }
    locals: { uninitializedThis }
    stack: { &#39;java/lang/String&#39; }
  Bytecode:
    0000000: 1208 1003 b800 0e2a b700 10b1          
</code></pre><p>&mldr; this time with a different message. And the reason is pretty clear: <em>Exceeded max stack size.</em></p><p>Checking back on the <code>javap -v</code> output:</p><pre tabindex=0><code>  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=1, locals=2, args_size=1
</code></pre><p>&mldr; it says that the maximum stack size is 1. Obviously that already is in contrast to the two values we push to the stack. To fix this, we actually have two options</p><ul><li><p>we can ask ASM to calculate the maximum stack size and update it accordingly (to do so, we would just have to instantiate the class writer with <code>COMPUTE_MAX</code> flag like this: <code>new ClassWriter(ClassWriter.COMPUTE_MAXS)</code>)</p></li><li><p>we can modify the number on our own, and (in this simple case) just add 2</p></li></ul><p>For real projects the former option would definitely be nicer. Especially since the second option easily leads to some waste. Our <code>track</code> calls likely don&rsquo;t happen with the stack at its maximum size. But let&rsquo;s neglect the couple of bytes potentially wasted, and override the <code>visitMaxs</code> method as well:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>	<span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>visitMaxs</span>(<span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> maxStack, <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> maxLocals) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>visitMaxs</span>(maxStack <span style=color:#f92672>+</span> 2, maxLocals);
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>&mldr; with that fixed, do we finally have the code necessary to track and that&rsquo;s not immediately crashing after some first simple examples?</p><p><a href=https://stefansiegl.de/2025/03/lets-create-a-coverage-analyzer-part-4/>Let&rsquo;s create a Coverage Analyzer, Part 4</a> follows up on this implementation.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://stefansiegl.de/tags/java/>Java</a></li><li><a href=https://stefansiegl.de/tags/java-agents/>Java Agents</a></li><li><a href=https://stefansiegl.de/tags/byte-code/>Byte Code</a></li></ul></footer></article></main><footer class=footer><span>© 2025 Stefan Siegl · all content is <a href=https://creativecommons.org/licenses/by-sa/4.0/deed>CC-BY-SA</a> · <a href=https://www.swyx.io/digital-garden-tos#for-visitors>Terms of Service</a></span> ·
<a href=/imprint>Imprint</a> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>