<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Let's create a Coverage Analyzer, Part 4 | ~stesie's musings</title>
<meta name=keywords content="Java,Java Agents,Byte Code,Instrumentation,Coverage Analyzer,Undercovered"><meta name=description content='This is part four of my journey creating a Java (Line) Coverage Analyzer.
This time around we&rsquo;ll test the implementation created in part three and look into details what still goes wrong.
One (simplified) example that crashes the current analyzer implementation is this one:
public class Demo3 { public static void main(final String[] argv) { final Stuff stuff = new Stuff( !getBoolean()); bla("value: " + stuff.boolValue()); } public static boolean getBoolean() { return true; } private static void bla(final String greeting) { System.'><meta name=author content><link rel=canonical href=https://stefansiegl.de/2025/03/lets-create-a-coverage-analyzer-part-4/><link crossorigin=anonymous href=/assets/css/stylesheet.0c89971808195fcfba02b00128bb5209e165ff89d76c2f0d04eaefef9e1bd82a.css integrity="sha256-DImXGAgZX8+6ArABKLtSCeFl/4nXbC8NBOrv754b2Co=" rel="preload stylesheet" as=style><link rel=icon href=https://stefansiegl.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://stefansiegl.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://stefansiegl.de/favicon-32x32.png><link rel=apple-touch-icon href=https://stefansiegl.de/apple-touch-icon.png><link rel=mask-icon href=https://stefansiegl.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://stefansiegl.de/2025/03/lets-create-a-coverage-analyzer-part-4/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Let's create a Coverage Analyzer, Part 4"><meta property="og:description" content='This is part four of my journey creating a Java (Line) Coverage Analyzer.
This time around we&rsquo;ll test the implementation created in part three and look into details what still goes wrong.
One (simplified) example that crashes the current analyzer implementation is this one:
public class Demo3 { public static void main(final String[] argv) { final Stuff stuff = new Stuff( !getBoolean()); bla("value: " + stuff.boolValue()); } public static boolean getBoolean() { return true; } private static void bla(final String greeting) { System.'><meta property="og:type" content="article"><meta property="og:url" content="https://stefansiegl.de/2025/03/lets-create-a-coverage-analyzer-part-4/"><meta property="article:section" content="pages"><meta property="article:published_time" content="2025-03-01T18:30:00+00:00"><meta property="article:modified_time" content="2025-03-01T18:30:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Let's create a Coverage Analyzer, Part 4"><meta name=twitter:description content='This is part four of my journey creating a Java (Line) Coverage Analyzer.
This time around we&rsquo;ll test the implementation created in part three and look into details what still goes wrong.
One (simplified) example that crashes the current analyzer implementation is this one:
public class Demo3 { public static void main(final String[] argv) { final Stuff stuff = new Stuff( !getBoolean()); bla("value: " + stuff.boolValue()); } public static boolean getBoolean() { return true; } private static void bla(final String greeting) { System.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Pages","item":"https://stefansiegl.de/pages/"},{"@type":"ListItem","position":2,"name":"Let's create a Coverage Analyzer, Part 4","item":"https://stefansiegl.de/2025/03/lets-create-a-coverage-analyzer-part-4/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Let's create a Coverage Analyzer, Part 4","name":"Let\u0027s create a Coverage Analyzer, Part 4","description":"This is part four of my journey creating a Java (Line) Coverage Analyzer.\nThis time around we\u0026rsquo;ll test the implementation created in part three and look into details what still goes wrong.\nOne (simplified) example that crashes the current analyzer implementation is this one:\npublic class Demo3 { public static void main(final String[] argv) { final Stuff stuff = new Stuff( !getBoolean()); bla(\u0026#34;value: \u0026#34; + stuff.boolValue()); } public static boolean getBoolean() { return true; } private static void bla(final String greeting) { System.","keywords":["Java","Java Agents","Byte Code","Instrumentation","Coverage Analyzer","Undercovered"],"articleBody":"This is part four of my journey creating a Java (Line) Coverage Analyzer.\nThis time around we’ll test the implementation created in part three and look into details what still goes wrong.\nOne (simplified) example that crashes the current analyzer implementation is this one:\npublic class Demo3 { public static void main(final String[] argv) { final Stuff stuff = new Stuff( !getBoolean()); bla(\"value: \" + stuff.boolValue()); } public static boolean getBoolean() { return true; } private static void bla(final String greeting) { System.out.println(greeting); } record Stuff(boolean boolValue) { } } … the line break between lines 3 and 4 is actually important. Having the argument on the same line wouldn’t cause the issue. However adding more arguments, and spreading these over multiple lines, would again trigger the issue.\nIf we run the example above against the current version of the analyzer, we’ll see this error message:\nError: Unable to initialize main class de.brokenpipe.dojo.undercovered.demo.Demo3\nCaused by: java.lang.ClassFormatError: StackMapTable format error: bad offset for Uninitialized in method ‘void de.brokenpipe.dojo.undercovered.demo.Demo3.main(java.lang.String[])’\nSo what is this Uninitialized thing?\nLet’s have a look at the byte code of the not instrumented code first:\npublic static void main(java.lang.String[]); stack=3, locals=2, args_size=1 0: new #7 // class de/brokenpipe/dojo/undercovered/demo/Demo3$Stuff 3: dup 4: invokestatic #9 // Method getBoolean:()Z 7: ifne 14 10: iconst_1 11: goto 15 14: iconst_0 15: invokespecial #15 // Method de/brokenpipe/dojo/undercovered/demo/Demo3$Stuff.\"\":(Z)V [...] LineNumberTable: line 6: 0 line 7: 4 [...] StackMapTable: number_of_entries = 2 frame_type = 255 /* full_frame */ offset_delta = 14 locals = [ class \"[Ljava/lang/String;\" ] stack = [ uninitialized 0, uninitialized 0 ] frame_type = 255 /* full_frame */ offset_delta = 0 locals = [ class \"[Ljava/lang/String;\" ] stack = [ uninitialized 0, uninitialized 0, int ] … the Stack Map Table again, our old friend 🙂\nFirst of all, note how the creation of the class instance (new opcode, in location 0) and the actual initialization (invokespecial opcode, in location 15) are actually two different steps. It is simply not the case, that the new opcode invokes the constructor.\nSince the Java code inverts the result of the getBoolean invocation, it also emits some code to actually invert the result. Since it’s using ifne and goto, which both are branch instructions targeting different locations … two entries to the Stack Map Table become necessary. And within these, it records, that the class instantiated by the new opcode in location 0 is not yet initialized.\nIf you have a close look at the Line Number Table, it becomes clear that our implementation will instrument at locations 0 \u0026 4 … and you can already guess what’s going wrong.\nLet’s have a look at the byte code after instrumentation:\npublic static void main(java.lang.String[]); stack=5, locals=2, args_size=1 0: ldc #16 // String de/brokenpipe/dojo/undercovered/demo/Demo3 2: bipush 6 4: invokestatic #22 // Method de/brokenpipe/dojo/undercovered/coverista/tracking/Tracker.track:(Ljava/lang/String;I)V 7: new #7 // class de/brokenpipe/dojo/undercovered/demo/Demo3$Stuff [...] StackMapTable: number_of_entries = 2 frame_type = 255 /* full_frame */ offset_delta = 21 locals = [ class \"[Ljava/lang/String;\" ] stack = [ uninitialized 0, uninitialized 0 ] … the stack frames are still properly written, but the offsets of the uninitialized still point to location 0. However at location 0 there’s now our ldc opcode, and the new is at 7 now. The goal is clear: we need to update that offset.\nASM’s way of handling this is, that it tracks the offsets using labels. Therefore let’s push our new label right before the new opcode and map the label in the visitFrame call. I’ve added a class-level field surrogateLabels to hold the mapping:\npublic class InstrumentingMethodVisitor extends MethodVisitor { private Label currentLabel = null; private Map\u003cLabel, Label\u003e surrogateLabels = new HashMap\u003c\u003e(); @Override public void visitFrame(final int type, final int numLocal, final Object[] local, final int numStack, final Object[] stack) { for (int i = 0; i \u003c numStack; i ++) { if (stack[i] instanceof Label \u0026\u0026 surrogateLabels.containsKey(stack[i])) { log.finer(\"applying surrogate label: \" + stack[1]); stack[i] = surrogateLabels.get(stack[i]); } } super.visitFrame(type, numLocal, local, numStack, stack); if (jumpLabels.contains(currentLineNumber)) { instrument(currentLineNumber); } } @Override public void visitLabel(final Label label) { super.visitLabel(label); currentLabel = label; } @Override public void visitTypeInsn(final int opcode, final String type) { if (opcode == Opcodes.NEW) { final var surrogateLabel = new Label(); super.visitLabel(surrogateLabel); surrogateLabels.put(currentLabel, surrogateLabel); } super.visitTypeInsn(opcode, type); } This implementation does three things:\nIn visitLabel (which is called first) the “current” label is recorded.\nThe visitTypeInsn, which is (among others) invoked for the NEW opcode, has some special handling for it. prior to delegating the call to the super method (which causes the opcode to be written), it also creates a new label, and adds an entry to the surrogateLabels map, mapping the current label to our surrogate.\nLast but not least visitFrame iterates the stack elements of the frame. For every label existing in the map, it uses the surrogate instead.\nAnd yay, that’s it. Our simple coverage analyzer finally seems to be working 🥳\nFinal source code is available from stesie/undercovered GitHub repository.\nBookkeeping So far the track method doesn’t do much. It just logs the invocation. With the goal of creating a coverage report in mind, obviously we have to collect that data. Since this project is mostly about collecting the data, and not about rendering a nice report, … I just want to dump the data to a JSON file. For the JSON Writing I just went on with the Jackson library.\nIn order to be able to also report uncovered lines, I’ve added another tiny MethodVisitor, that just “registers” the line with the tracking layer and also passes information to which method the line is related. The latter is important for “method coverage” aggregation.\nAfter all nothing fancy:\npublic class LineRegisteringMethodVisitor extends MethodVisitor { private final ClassTracker classTracker; private final String methodName; private final String descriptor; protected LineRegisteringMethodVisitor(final MethodVisitor methodVisitor, final ClassTracker classTracker, final String methodName, final String descriptor) { super(Opcodes.ASM9, methodVisitor); this.classTracker = classTracker; this.methodName = methodName; this.descriptor = descriptor; } @Override public void visitLineNumber(final int line, final Label start) { super.visitLineNumber(line, start); classTracker.trackLine(line, methodName, descriptor); } } The Tracker instance holds a static reference to the collector, simply tracking each and every invocation like so:\npublic class Tracker { static TrackingCollector currentCollector; public static void track(final String callingClass, final int line) { log.finer(\"hit \" + callingClass + \":\" + line); currentCollector.trackClass(callingClass).line(line).hit(); } public static TrackingCollector createCollector(final Set\u003cString\u003e includePatterns, final Set\u003cString\u003e excludePatterns) { currentCollector = new TrackingCollector(includePatterns, excludePatterns); return currentCollector; } } Last but not least we can register a shutdown hook from our premain method, that dumps the collected data to the JSON file, once program execution comes to an end.\npublic class UndercoveredAgent { public static void premain(final String agentArgs, final Instrumentation inst) { // ... Runtime.getRuntime().addShutdownHook( new Thread(() -\u003e { inst.removeTransformer(transformer); if (args.destfile != null) { serializeCollectorToJson(collector, args.destfile); } }) ); } private static void serializeCollectorToJson(final TrackingCollector collector, final String destfile) { final var objectMapper = new ObjectMapper(); try (final var writer = new java.io.FileWriter(destfile)) { objectMapper.writeValue(writer, collector); } catch (final Exception e) { log.severe(\"Unable to serialize collector to JSON:\" + e); } } } … and that’s it. We finally have an agent, that can collect coverage data and store that information to a json file.\nRunning the demo application with coverage collection one last time:\n$ java -javaagent:agent/target/agent-1.0-SNAPSHOT.jar=destfile=cover.json -cp demo/target/demo-1.0-SNAPSHOT.jar de.brokenpipe.dojo.undercovered.demo.Demo Hello World to the blarg Resulting json report, after running the demo application:\n{ \"includePatterns\": [], \"excludePatterns\": [], \"classes\": [ { \"className\": \"de/brokenpipe/dojo/undercovered/demo/Demo\", \"lines\": [ { \"line\": 3, \"methodSignature\": \"()V\", \"hitCount\": 0 }, { \"line\": 6, \"methodSignature\": \"main([Ljava/lang/String;)V\", \"hitCount\": 1 }, { \"line\": 8, \"methodSignature\": \"main([Ljava/lang/String;)V\", \"hitCount\": 1 }, { \"line\": 9, \"methodSignature\": \"main([Ljava/lang/String;)V\", \"hitCount\": 1 }, { \"line\": 11, \"methodSignature\": \"main([Ljava/lang/String;)V\", \"hitCount\": 1 }, { \"line\": 14, \"methodSignature\": \"bla(Ljava/lang/String;)V\", \"hitCount\": 2 }, { \"line\": 15, \"methodSignature\": \"bla(Ljava/lang/String;)V\", \"hitCount\": 2 } ] } ] } What’s left ?! So far this implementation solely bothers to collect line coverage information. For branch coverage we would need to add some special handling around if statements and switch statements/expressions. Tracking the if branch itself should be straight forward. However we’d need to take care of missing else branches, so we also collect information how often an if branch wasn’t entered. Yet we’ve already seen all the means necessary to do so in the last article. If the else branch is missing, we’d just need to add one more goto and create a stack frame entry of our own. Even the latter should be easy, given that there already must be a stack frame entry for the jump target, that skips the if branch … so we could just duplicate that one.\nFurthermore a “real” coverage tracker likely shouldn’t pull Jackson into the classpath 😅\nAnd JaCoCo moves itself into a dedicated random package name, so running code cannot make assumptions on it. And having the package randomized would also allow us to instrument ourselves.\nLast but not least, obviously we need an IntelliJ Plugin.\n… and very likely I’m missing out on some obvious points, and likely also this implementation is still buggy \u0026 incomplete 😈\n","wordCount":"1502","inLanguage":"en","datePublished":"2025-03-01T18:30:00Z","dateModified":"2025-03-01T18:30:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://stefansiegl.de/2025/03/lets-create-a-coverage-analyzer-part-4/"},"publisher":{"@type":"Organization","name":"~stesie's musings","logo":{"@type":"ImageObject","url":"https://stefansiegl.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://stefansiegl.de/ accesskey=h title="~stesie's musings (Alt + H)">~stesie's musings</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://stefansiegl.de/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://stefansiegl.de/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://stefansiegl.de/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://stefansiegl.de/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Let's create a Coverage Analyzer, Part 4</h1><div class=post-meta>Status: 🌳 Evergreen&nbsp;·&nbsp;Planted:&nbsp;<span title='2025-03-01 18:30:00 +0000 UTC'>Mar 1, 2025</span>&nbsp;·&nbsp;8 min</div></header><div class=post-content><p>This is part four of my journey creating a Java (Line) Coverage Analyzer.</p><p>This time around we&rsquo;ll test the <a href=https://stefansiegl.de/2025/03/lets-create-a-coverage-analyzer-part-3/>implementation created in part three</a> and look into details what still goes wrong.</p><p>One (simplified) example that crashes the current analyzer implementation is this one:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Demo3</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>final</span> String<span style=color:#f92672>[]</span> argv) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>final</span> Stuff stuff <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Stuff(
</span></span><span style=display:flex><span>				<span style=color:#f92672>!</span>getBoolean());
</span></span><span style=display:flex><span>		bla(<span style=color:#e6db74>&#34;value: &#34;</span> <span style=color:#f92672>+</span> stuff.<span style=color:#a6e22e>boolValue</span>());
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>getBoolean</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>bla</span>(<span style=color:#66d9ef>final</span> String greeting) {
</span></span><span style=display:flex><span>		System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(greeting);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>record</span> <span style=color:#a6e22e>Stuff</span>(<span style=color:#66d9ef>boolean</span> boolValue) {
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr; the line break between lines 3 and 4 is actually important. Having the argument on the same line wouldn&rsquo;t cause the issue. However adding more arguments, and spreading these over multiple lines, would again trigger the issue.</p><p>If we run the example above against the current version of the analyzer, we&rsquo;ll see this error message:</p><blockquote><p>Error: Unable to initialize main class de.brokenpipe.dojo.undercovered.demo.Demo3</p><p>Caused by: java.lang.ClassFormatError: StackMapTable format error: bad offset for Uninitialized in method &lsquo;void de.brokenpipe.dojo.undercovered.demo.Demo3.main(java.lang.String[])&rsquo;</p></blockquote><p>So what is this <em>Uninitialized</em> thing?</p><p>Let&rsquo;s have a look at the byte code of the <em>not</em> instrumented code first:</p><pre tabindex=0><code>  public static void main(java.lang.String[]);
      stack=3, locals=2, args_size=1
         0: new           #7                  // class de/brokenpipe/dojo/undercovered/demo/Demo3$Stuff
         3: dup
         4: invokestatic  #9                  // Method getBoolean:()Z
         7: ifne          14
        10: iconst_1
        11: goto          15
        14: iconst_0
        15: invokespecial #15                 // Method de/brokenpipe/dojo/undercovered/demo/Demo3$Stuff.&#34;&lt;init&gt;&#34;:(Z)V
[...]
      LineNumberTable:
        line 6: 0
        line 7: 4
[...]
      StackMapTable: number_of_entries = 2
        frame_type = 255 /* full_frame */
          offset_delta = 14
          locals = [ class &#34;[Ljava/lang/String;&#34; ]
          stack = [ uninitialized 0, uninitialized 0 ]
        frame_type = 255 /* full_frame */
          offset_delta = 0
          locals = [ class &#34;[Ljava/lang/String;&#34; ]
          stack = [ uninitialized 0, uninitialized 0, int ]
</code></pre><p>&mldr; the Stack Map Table again, our old friend 🙂</p><p>First of all, note how the creation of the class instance (<code>new</code> opcode, in location 0) and the actual initialization (<code>invokespecial</code> opcode, in location 15) are actually two different steps. It is simply <em>not</em> the case, that the <code>new</code> opcode invokes the constructor.</p><p>Since the Java code inverts the result of the <code>getBoolean</code> invocation, it also emits some code to actually invert the result. Since it&rsquo;s using <code>ifne</code> and <code>goto</code>, which both are branch instructions targeting different locations &mldr; two entries to the Stack Map Table become necessary. And within these, it records, that the class instantiated by the <code>new</code> opcode in location 0 is not yet <em>initialized</em>.</p><p>If you have a close look at the Line Number Table, it becomes clear that our implementation will instrument at locations 0 & 4 &mldr; and you can already guess what&rsquo;s going wrong.</p><p>Let&rsquo;s have a look at the byte code after instrumentation:</p><pre tabindex=0><code>  public static void main(java.lang.String[]);
      stack=5, locals=2, args_size=1
         0: ldc           #16                 // String de/brokenpipe/dojo/undercovered/demo/Demo3
         2: bipush        6
         4: invokestatic  #22                 // Method de/brokenpipe/dojo/undercovered/coverista/tracking/Tracker.track:(Ljava/lang/String;I)V
         7: new           #7                  // class de/brokenpipe/dojo/undercovered/demo/Demo3$Stuff
[...]        
      StackMapTable: number_of_entries = 2
        frame_type = 255 /* full_frame */
          offset_delta = 21
          locals = [ class &#34;[Ljava/lang/String;&#34; ]
          stack = [ uninitialized 0, uninitialized 0 ]
</code></pre><p>&mldr; the stack frames are still properly written, but the offsets of the <code>uninitialized</code> still point to location 0. However at location 0 there&rsquo;s now our <code>ldc</code> opcode, and the <code>new</code> is at 7 now. The goal is clear: we need to update that offset.</p><p>ASM&rsquo;s way of handling this is, that it tracks the offsets using labels. Therefore let&rsquo;s push our new label right before the <code>new</code> opcode and map the label in the <code>visitFrame</code> call. I&rsquo;ve added a class-level field <code>surrogateLabels</code> to hold the mapping:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>InstrumentingMethodVisitor</span> <span style=color:#66d9ef>extends</span> MethodVisitor {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> Label currentLabel <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> Map<span style=color:#f92672>&lt;</span>Label, Label<span style=color:#f92672>&gt;</span> surrogateLabels <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>visitFrame</span>(<span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> type, <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> numLocal, <span style=color:#66d9ef>final</span> Object<span style=color:#f92672>[]</span> local, <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> numStack,
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>final</span> Object<span style=color:#f92672>[]</span> stack) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> numStack; i <span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (stack<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#66d9ef>instanceof</span> Label <span style=color:#f92672>&amp;&amp;</span> surrogateLabels.<span style=color:#a6e22e>containsKey</span>(stack<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>)) {
</span></span><span style=display:flex><span>				log.<span style=color:#a6e22e>finer</span>(<span style=color:#e6db74>&#34;applying surrogate label: &#34;</span> <span style=color:#f92672>+</span> stack<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>				stack<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> surrogateLabels.<span style=color:#a6e22e>get</span>(stack<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>visitFrame</span>(type, numLocal, local, numStack, stack);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (jumpLabels.<span style=color:#a6e22e>contains</span>(currentLineNumber)) {
</span></span><span style=display:flex><span>			instrument(currentLineNumber);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>visitLabel</span>(<span style=color:#66d9ef>final</span> Label label) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>visitLabel</span>(label);
</span></span><span style=display:flex><span>		currentLabel <span style=color:#f92672>=</span> label;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>visitTypeInsn</span>(<span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> opcode, <span style=color:#66d9ef>final</span> String type) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (opcode <span style=color:#f92672>==</span> Opcodes.<span style=color:#a6e22e>NEW</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>final</span> <span style=color:#66d9ef>var</span> surrogateLabel <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Label();
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>visitLabel</span>(surrogateLabel);
</span></span><span style=display:flex><span>			surrogateLabels.<span style=color:#a6e22e>put</span>(currentLabel, surrogateLabel);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>visitTypeInsn</span>(opcode, type);
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>This implementation does three things:</p><ul><li><p>In <code>visitLabel</code> (which is called first) the &ldquo;current&rdquo; label is recorded.</p></li><li><p>The <code>visitTypeInsn</code>, which is (among others) invoked for the <code>NEW</code> opcode, has some special handling for it. <em>prior</em> to delegating the call to the super method (which causes the opcode to be written), it also creates a new label, and adds an entry to the <code>surrogateLabels</code> map, mapping the current label to our surrogate.</p></li><li><p>Last but not least <code>visitFrame</code> iterates the stack elements of the frame. For every label existing in the map, it uses the surrogate instead.</p></li></ul><p>And yay, that&rsquo;s it. Our simple coverage analyzer finally seems to be working 🥳</p><p>Final source code is available from <a href=https://github.com/stesie/undercovered>stesie/undercovered GitHub repository</a>.</p><h2 id=bookkeeping>Bookkeeping<a hidden class=anchor aria-hidden=true href=#bookkeeping>#</a></h2><p>So far the <code>track</code> method doesn&rsquo;t do much. It just logs the invocation. With the goal of creating a coverage report in mind, obviously we have to collect that data. Since this project is mostly about collecting the data, and not about rendering a nice report, &mldr; I just want to dump the data to a JSON file. For the JSON Writing I just went on with the Jackson library.</p><p>In order to be able to also report uncovered lines, I&rsquo;ve added another tiny <code>MethodVisitor</code>, that just &ldquo;registers&rdquo; the line with the tracking layer and also passes information to which method the line is related. The latter is important for &ldquo;method coverage&rdquo; aggregation.</p><p>After all nothing fancy:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LineRegisteringMethodVisitor</span> <span style=color:#66d9ef>extends</span> MethodVisitor {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> ClassTracker classTracker;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> String methodName;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> String descriptor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>protected</span> <span style=color:#a6e22e>LineRegisteringMethodVisitor</span>(<span style=color:#66d9ef>final</span> MethodVisitor methodVisitor,
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>final</span> ClassTracker classTracker, <span style=color:#66d9ef>final</span> String methodName, <span style=color:#66d9ef>final</span> String descriptor) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>super</span>(Opcodes.<span style=color:#a6e22e>ASM9</span>, methodVisitor);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>classTracker</span> <span style=color:#f92672>=</span> classTracker;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>methodName</span> <span style=color:#f92672>=</span> methodName;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>descriptor</span> <span style=color:#f92672>=</span> descriptor;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>visitLineNumber</span>(<span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> line, <span style=color:#66d9ef>final</span> Label start) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>visitLineNumber</span>(line, start);
</span></span><span style=display:flex><span>		classTracker.<span style=color:#a6e22e>trackLine</span>(line, methodName, descriptor);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>Tracker</code> instance holds a static reference to the collector, simply tracking each and every invocation like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Tracker</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>static</span> TrackingCollector currentCollector;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>track</span>(<span style=color:#66d9ef>final</span> String callingClass, <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> line) {
</span></span><span style=display:flex><span>		log.<span style=color:#a6e22e>finer</span>(<span style=color:#e6db74>&#34;hit &#34;</span> <span style=color:#f92672>+</span> callingClass <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;:&#34;</span> <span style=color:#f92672>+</span> line);
</span></span><span style=display:flex><span>		currentCollector.<span style=color:#a6e22e>trackClass</span>(callingClass).<span style=color:#a6e22e>line</span>(line).<span style=color:#a6e22e>hit</span>();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> TrackingCollector <span style=color:#a6e22e>createCollector</span>(<span style=color:#66d9ef>final</span> Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> includePatterns,
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>final</span> Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> excludePatterns) {
</span></span><span style=display:flex><span>		currentCollector <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TrackingCollector(includePatterns, excludePatterns);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> currentCollector;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Last but not least we can register a shutdown hook from our <code>premain</code> method, that dumps the collected data to the JSON file, once program execution comes to an end.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UndercoveredAgent</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>premain</span>(<span style=color:#66d9ef>final</span> String agentArgs, <span style=color:#66d9ef>final</span> Instrumentation inst) {
</span></span><span style=display:flex><span><span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>		Runtime.<span style=color:#a6e22e>getRuntime</span>().<span style=color:#a6e22e>addShutdownHook</span>(
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>					inst.<span style=color:#a6e22e>removeTransformer</span>(transformer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>if</span> (args.<span style=color:#a6e22e>destfile</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>						serializeCollectorToJson(collector, args.<span style=color:#a6e22e>destfile</span>);
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>				})
</span></span><span style=display:flex><span>		);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>serializeCollectorToJson</span>(<span style=color:#66d9ef>final</span> TrackingCollector collector, <span style=color:#66d9ef>final</span> String destfile) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>final</span> <span style=color:#66d9ef>var</span> objectMapper <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectMapper();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>try</span> (<span style=color:#66d9ef>final</span> <span style=color:#66d9ef>var</span> writer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> java.<span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>FileWriter</span>(destfile)) {
</span></span><span style=display:flex><span>			objectMapper.<span style=color:#a6e22e>writeValue</span>(writer, collector);
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>catch</span> (<span style=color:#66d9ef>final</span> Exception e) {
</span></span><span style=display:flex><span>			log.<span style=color:#a6e22e>severe</span>(<span style=color:#e6db74>&#34;Unable to serialize collector to JSON:&#34;</span> <span style=color:#f92672>+</span> e);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr; and that&rsquo;s it. We finally have an agent, that can collect coverage data and store that information to a json file.</p><p>Running the demo application with coverage collection one last time:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ java -javaagent:agent/target/agent-1.0-SNAPSHOT.jar<span style=color:#f92672>=</span>destfile<span style=color:#f92672>=</span>cover.json -cp demo/target/demo-1.0-SNAPSHOT.jar de.brokenpipe.dojo.undercovered.demo.Demo
</span></span><span style=display:flex><span>Hello World
</span></span><span style=display:flex><span>to the blarg
</span></span></code></pre></div><p>Resulting json report, after running the demo application:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;includePatterns&#34;</span>: [],
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;excludePatterns&#34;</span>: [],
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;classes&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;className&#34;</span>: <span style=color:#e6db74>&#34;de/brokenpipe/dojo/undercovered/demo/Demo&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;lines&#34;</span>: [
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;line&#34;</span>: <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;methodSignature&#34;</span>: <span style=color:#e6db74>&#34;&lt;init&gt;()V&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;hitCount&#34;</span>: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;line&#34;</span>: <span style=color:#ae81ff>6</span>,
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;methodSignature&#34;</span>: <span style=color:#e6db74>&#34;main([Ljava/lang/String;)V&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;hitCount&#34;</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;line&#34;</span>: <span style=color:#ae81ff>8</span>,
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;methodSignature&#34;</span>: <span style=color:#e6db74>&#34;main([Ljava/lang/String;)V&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;hitCount&#34;</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;line&#34;</span>: <span style=color:#ae81ff>9</span>,
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;methodSignature&#34;</span>: <span style=color:#e6db74>&#34;main([Ljava/lang/String;)V&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;hitCount&#34;</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;line&#34;</span>: <span style=color:#ae81ff>11</span>,
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;methodSignature&#34;</span>: <span style=color:#e6db74>&#34;main([Ljava/lang/String;)V&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;hitCount&#34;</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;line&#34;</span>: <span style=color:#ae81ff>14</span>,
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;methodSignature&#34;</span>: <span style=color:#e6db74>&#34;bla(Ljava/lang/String;)V&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;hitCount&#34;</span>: <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;line&#34;</span>: <span style=color:#ae81ff>15</span>,
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;methodSignature&#34;</span>: <span style=color:#e6db74>&#34;bla(Ljava/lang/String;)V&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:#f92672>&#34;hitCount&#34;</span>: <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      ]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=whats-left->What&rsquo;s left ?!<a hidden class=anchor aria-hidden=true href=#whats-left->#</a></h2><p>So far this implementation solely bothers to collect line coverage information. For branch coverage we would need to add some special handling around if statements and switch statements/expressions. Tracking the if branch itself should be straight forward. However we&rsquo;d need to take care of missing else branches, so we also collect information how often an if branch wasn&rsquo;t entered. Yet we&rsquo;ve already seen all the means necessary to do so in the last article. If the else branch is missing, we&rsquo;d just need to add one more <code>goto</code> and create a stack frame entry of our own. Even the latter should be easy, given that there already must be a stack frame entry for the jump target, that skips the if branch &mldr; so we could just duplicate that one.</p><p>Furthermore a &ldquo;real&rdquo; coverage tracker likely shouldn&rsquo;t pull Jackson into the classpath 😅</p><p>And JaCoCo moves itself into a dedicated random package name, so running code cannot make assumptions on it. And having the package randomized would also allow us to instrument ourselves.</p><p>Last but not least, <a href=https://stefansiegl.de/2025/03/writing-an-intellij-plugin/>obviously we need an IntelliJ Plugin</a>.</p><p>&mldr; and very likely I&rsquo;m missing out on some obvious points, and likely also this implementation is still buggy & incomplete 😈</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://stefansiegl.de/tags/java/>Java</a></li><li><a href=https://stefansiegl.de/tags/java-agents/>Java Agents</a></li><li><a href=https://stefansiegl.de/tags/byte-code/>Byte Code</a></li><li><a href=https://stefansiegl.de/tags/instrumentation/>Instrumentation</a></li><li><a href=https://stefansiegl.de/tags/coverage-analyzer/>Coverage Analyzer</a></li><li><a href=https://stefansiegl.de/tags/undercovered/>Undercovered</a></li></ul></footer></article></main><footer class=footer><span>© 2025 Stefan Siegl · all content is <a href=https://creativecommons.org/licenses/by-sa/4.0/deed>CC-BY-SA</a> · <a href=https://www.swyx.io/digital-garden-tos#for-visitors>Terms of Service</a></span> ·
<a href=/imprint>Imprint</a> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>