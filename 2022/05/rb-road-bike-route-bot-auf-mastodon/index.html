<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>(rb)² – Road Bike Route Bot auf Mastodon | stesie's musings</title>
<meta name=keywords content="Bot,Geodaten,Mastodon,OpenStreetMap"><meta name=description content="This was initially published on https://blog.mayflower.de/12803-mastodon-bot.html Ein Erfahrungsbericht, weil ich …
mal wieder was mit Geodaten machen wollte (und mich OpenStreetMap schon eine ganze Weile immer wieder umtreibt)
schon länger darüber nachdenke, wie gut es wohl funktioniert, einen zufälligen Fahrrad-Routenvorschlag nach eigenem Gusto zu erzeugen
schon länger im Fediverse (Mastodon) bin und während des Alle-Verlassen-Twitter-Hypes einen Bot zu bauen nahe liegt
Also los geht’s. How hard can it be?"><meta name=author content="Stefan Siegl"><link rel=canonical href=https://stesie.github.io/2022/05/rb-road-bike-route-bot-auf-mastodon/><link crossorigin=anonymous href=/assets/css/stylesheet.eaf1c0e3f8327b0eecb58a6cafac5ca1bc09ab794ba654be960d9aa6b1cdd1c7.css integrity="sha256-6vHA4/gyew7stYpsr6xcobwJq3lLplS+lg2aprHN0cc=" rel="preload stylesheet" as=style><link rel=icon href=https://stesie.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://stesie.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://stesie.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://stesie.github.io/apple-touch-icon.png><link rel=mask-icon href=https://stesie.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://stesie.github.io/2022/05/rb-road-bike-route-bot-auf-mastodon/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="(rb)² – Road Bike Route Bot auf Mastodon"><meta property="og:description" content="This was initially published on https://blog.mayflower.de/12803-mastodon-bot.html Ein Erfahrungsbericht, weil ich …
mal wieder was mit Geodaten machen wollte (und mich OpenStreetMap schon eine ganze Weile immer wieder umtreibt)
schon länger darüber nachdenke, wie gut es wohl funktioniert, einen zufälligen Fahrrad-Routenvorschlag nach eigenem Gusto zu erzeugen
schon länger im Fediverse (Mastodon) bin und während des Alle-Verlassen-Twitter-Hypes einen Bot zu bauen nahe liegt
Also los geht’s. How hard can it be?"><meta property="og:type" content="article"><meta property="og:url" content="https://stesie.github.io/2022/05/rb-road-bike-route-bot-auf-mastodon/"><meta property="article:section" content="pages"><meta property="article:published_time" content="2022-05-09T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-03T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="(rb)² – Road Bike Route Bot auf Mastodon"><meta name=twitter:description content="This was initially published on https://blog.mayflower.de/12803-mastodon-bot.html Ein Erfahrungsbericht, weil ich …
mal wieder was mit Geodaten machen wollte (und mich OpenStreetMap schon eine ganze Weile immer wieder umtreibt)
schon länger darüber nachdenke, wie gut es wohl funktioniert, einen zufälligen Fahrrad-Routenvorschlag nach eigenem Gusto zu erzeugen
schon länger im Fediverse (Mastodon) bin und während des Alle-Verlassen-Twitter-Hypes einen Bot zu bauen nahe liegt
Also los geht’s. How hard can it be?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Pages","item":"https://stesie.github.io/pages/"},{"@type":"ListItem","position":2,"name":"(rb)² – Road Bike Route Bot auf Mastodon","item":"https://stesie.github.io/2022/05/rb-road-bike-route-bot-auf-mastodon/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"(rb)² – Road Bike Route Bot auf Mastodon","name":"(rb)² – Road Bike Route Bot auf Mastodon","description":"This was initially published on https://blog.mayflower.de/12803-mastodon-bot.html Ein Erfahrungsbericht, weil ich …\nmal wieder was mit Geodaten machen wollte (und mich OpenStreetMap schon eine ganze Weile immer wieder umtreibt)\nschon länger darüber nachdenke, wie gut es wohl funktioniert, einen zufälligen Fahrrad-Routenvorschlag nach eigenem Gusto zu erzeugen\nschon länger im Fediverse (Mastodon) bin und während des Alle-Verlassen-Twitter-Hypes einen Bot zu bauen nahe liegt\nAlso los geht’s. How hard can it be?","keywords":["Bot","Geodaten","Mastodon","OpenStreetMap"],"articleBody":" This was initially published on https://blog.mayflower.de/12803-mastodon-bot.html Ein Erfahrungsbericht, weil ich …\nmal wieder was mit Geodaten machen wollte (und mich OpenStreetMap schon eine ganze Weile immer wieder umtreibt)\nschon länger darüber nachdenke, wie gut es wohl funktioniert, einen zufälligen Fahrrad-Routenvorschlag nach eigenem Gusto zu erzeugen\nschon länger im Fediverse (Mastodon) bin und während des Alle-Verlassen-Twitter-Hypes einen Bot zu bauen nahe liegt\nAlso los geht’s. How hard can it be?\nZunächst soll nicht unerwähnt bleiben, dass Dienste wie Strava erlauben, eine zufällige Route zu erzeugen; meinen Geschmack treffen die Ergebnisse jedoch eher selten. Wenn man “nur Straße” auswählt, wird man häufig über Staats- und teilweise auch Bundesstraßen geführt, was ich (insbesondere alleine) ätzend finde.\nKartenmaterial Ganz grundsätzlich brauchen wir zunächst einmal Kartenmaterial, weil eine Route ohne Straßen und Karte nicht funktioniert. Zum Glück gibt es das großartige Projekt OpenStreetMap, bei dem viele Freiwillige Kartendaten zusammen tragen. Meist in sehr hoher Qualität, und das auch was Nebenstraßen angeht. Und gerade dort macht es mit dem Rad auch einen großen Unterschied, wie es um Belag und Oberflächenbeschaffenheit bestellt ist.\nOpenStreetMap ist erstmal eine große Datenbank, in der alle möglichen Informationen “gemapped” sind. Das geht beim Offensichtlichen los: Straßen und Häuser. Umfasst aber auch Gleise, Läden \u0026 Cafes, Stromtrassen, Bushaltestellen, Glascontainer, Mülleimer, Bänke … kurzum alles, was irgendwie mit Geodaten zu tun hat und zu dem sich bisher Freiwillige fanden, es einzupflegen. An diesen Elementen hängen dann mit Schlüssel-Wert-Paaren weitere Informationen, wie beispielsweise Straßenbelag, Wegbeschaffenheit, Gehsteig vorhanden, Beleuchtet, etc.\nUns interessieren davon erstmal nur Wege. Und da nur die Typen highway (Straße), track (sonstige Wege) und path (Pfade). Die Straßen sind dabei weiter detailliert, sodass man Bundesstraßen (primary), Staatsstraßen (secondary), Kreisstraßen (tertiary), Ortsverbindungsstraßen (unclassified), etc. auseinanderhalten kann.\nEin (naiver) erster Ansatz Wir haben einen Startpunkt und eine grobe Idee von der Streckenlänge. Anschließend …\nberechnen wir den Radius eines Kreises, der im Umfang der gewünschten Streckenlänge entspricht\nwählen wir einen zufälligen Kreis dieses Radiuses, der unseren Startpunkt schneidet (damit bestimmen wir die Himmelsrichtung in die die Runde geht)\nwählen wir fünf zufällige Checkpoints, die auf diesem Kreis liegen (wobei einer der Startpunkt ist)\nsuchen wir für jeden Checkpoint einen Punkt, den wir potentiell anfahren wollen/können (anders ausgedrückt: suche den nächst gelegenen Punkt, der auf einer Kreis- oder Ortsverbindungsstraße liegt – schließlich wollen wir nicht viermal auf den Acker laufen)\nsuchen wir eine Route von Checkpoint zu Checkpoint\n… damit haben wir eine Route. Um diese dann auf Mastodon zu bringen, brauchen wir einerseits einen API-Client, andererseits noch eine Möglichkeit, die Route auf einer Karte darzustellen. Weil ohne Bild wäre der Tröt (“Tweet” in Mastodon-Lingo) wenig attraktiv.\nBestandsaufnahme Nachdem wir das nicht alles selbst bauen wollen, brauchen wir im Wesentlichen also\neinen “fernsteuerbaren” Router\neine Möglichkeit, wie wir die nächstgelegene geeignete Straße zu einem gegebenen Punkt finden können.\nBesagter Router muss nicht nur skriptbar sein und auf OpenStreetMap fußen, sondern soll flexibel/clever genug sein was die Streckenauswahl betrifft und – optional – auch das Höhenprofil berücksichtigen.\nHier kommt BRouter ins Spiel. Das ist eine Java-Anwendung (ursprünglich für Android), die man mit einem Routing-Profil füttern kann, und dann via HTTP die “beste” Strecke zwischen zwei (oder mehr) Punkten abfragen kann. Besagter BRouter bringt auch gleich ein Profil mit dem tollen Namen fastbike-verylowtraffic mit, das genau das tut was es verspricht: nur befestigte Wege, wenn möglich Kreis- oder Ortsverbindungsstraßen und Radwege. Standardmäßig ohne Berücksichtigung der Höhenmeter, das kann man auf Wunsch jedoch aktivieren.\nBei der initialen Suche nach geeigneten Checkpoints bietet sich die Overpass API an. Dieser kann man beliebige Anfragen in einer speziellen Abfragesprache (Overpass Query Language) stellen. Im einfachsten Fall die Suche nach z. B. einem Geldautomaten in einem bestimmten Bereich (typischerweise rechteckig). Es gibt jedoch auch einen around-Filter, mit dem man Objekte relativ zu anderen Elementen suchen kann.\nDie Abfrage selbst wirkt zunächst arkan:\n[out:json]; (way [highway~'tertiary|unclassified'] (around:1000.0,49.84178672462459,10.06466533810437); \u003e; ); out; Sehen wir uns die Abfrage genauer an:\nwir fordern eine Antwort in JSON (statt XML)\nsuchen einen/alle Weg/e\nmit Attribut highway=tertiary oder highway=unclassified\nim Umkreis von 1000 Metern um einen gegebenen Punkt\nvon den so selektierten Wegen sollen sodann die Punkte (aka parents) abgefragt werden (\u003e;)\nund das Ergebnis wollen wir auch haben (out;)\nUmsetzung Meine Lieblingsprogrammiersprache ist TypeScript. Eine kurze Recherche hat gezeigt, dass es gut gepflegte NPM-Module zum Ansprechen von Overpass (overpass-ts) und für erdräumliche Berechnungen (@turf/turf) gibt.\nAlle Funktionen von turf basieren auf GeoJSON, einem offenem Format, um eben geografische Daten in Form sog. Features zu repräsentieren. Solche Features können dann Punkte, Linien oder Polygone sein.\nUm den Ablauf des Skriptes transparenter zu bekommen, bietet es sich an, sämtliche Zwischenschritte als GeoJSON-FeatureCollection abzuspeichern. Unter geojson.io findet sich ein Online-Viewer, in den man jenes GeoJSON dann kopieren (und sodann betrachten) kann.\nAn diesem lässt sich dann gut erkennen, wie die Anwendung Schritt für Schritt vorgeht:\nWas passiert hier eigentlich? Sehen wir uns nun einmal im Detail an, was auf diesem Bild alles zu sehen ist:\nder Startpunkt (= grauer Marker) direkt in Würzburg\nKreis um diesen ziehen und einen Punkt davon als Routenmittelpunkt bestimmen (= grüner Marker)\nKreis um den grünen Marker bestimmen und fünf Checkpunkte auf diesem festlegen (= graues Polygon)\nfür alle Ecken (mit Overpass) die nächstgelegene (geeignete) Straße finden (= gelbliche Marker/Polygon)\nmit BRouter Routen zwischen ebendiesen Punkten erstellen (= rote Linien)\n“dead ends” entfernen, also Wege, die zu gelben Markern führen und dann direkt wieder zurück (= rote Marker)\nDie Koordinaten von Startpunkt und (korrigierten) Checkpoint-Markern können wir dann ein letztes mal dem BRouter füttern, der daraus eine GPX-Datei zaubert. GPX (= GPS Exchange Format) ist ein offenes XML-Format, mit dem Routen beschrieben werden können und das von den üblichen GPS-Geräten verstanden wird.\nDer o.g. Viewer für GeoJSON kann übrigens, trotz des Namens, auch GPX laden.\nGrafik rendern Ein Tröt ohne Bild ist langweilig. Aber wie bekommen wir einen Screenshot einer Karte mit unserer Route darauf?\nVielleicht nicht die effizienteste Lösung, aber zumindest straight forward: wir nehmen einfach einen Browser plus die Standard-JavaScript-Library zum Kartenrendering: Leaflet nebst GPX-Track-Plugin.\nNun brauchen wir nur noch etwas, das uns den Screenshot auf Kommando anfertigt: Googles Rendertron. Rendertron kann man auch wieder einfach per HTTP aufrufen, die URL übergeben (+ gewünschte Größe) und bekommt den Screenshot im JPG-Format zurück.\nAutomatisch Tröten Jetzt brauchen wir noch einen (Bot-)Account auf der Mastodon-Instanz unserer Wahl. In meinem Fall ist das wue.social. Und ein CLI-Tool, mit dem wir Route nebst Bild tröten können: toot.\nDas Ergebnis all der Arbeit? Ein Tröt:\nDamit kann unser Mashup auf die Zielgerade: noch ein bisschen Docker und ein paar Cronjobs – fertig ist der Bot :-)\n… und der ganze Rest Natürlich kann ich euch viel erzählen – ihr könnt euch aber auch selbst vom Bot überzeugen:\nProfilseite des Bots: @rbrb\nQuellcode des Projekts\n","wordCount":"1115","inLanguage":"en","datePublished":"2022-05-09T00:00:00Z","dateModified":"2025-01-03T00:00:00Z","author":{"@type":"Person","name":"Stefan Siegl"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://stesie.github.io/2022/05/rb-road-bike-route-bot-auf-mastodon/"},"publisher":{"@type":"Organization","name":"stesie's musings","logo":{"@type":"ImageObject","url":"https://stesie.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://stesie.github.io/ accesskey=h title="stesie's musings (Alt + H)">stesie's musings</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://stesie.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://stesie.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://stesie.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://stesie.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">(rb)² – Road Bike Route Bot auf Mastodon</h1><div class=post-meta><span title='2022-05-09 00:00:00 +0000 UTC'>May 9, 2022</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Stefan Siegl</div></header><div class=post-content><div class=important>This was initially published on <a href=https://blog.mayflower.de/12803-mastodon-bot.html>https://blog.mayflower.de/12803-mastodon-bot.html</a></div><p>Ein Erfahrungsbericht, weil ich …</p><ul><li><p>mal wieder was mit Geodaten machen wollte (und mich OpenStreetMap schon eine ganze Weile immer wieder umtreibt)</p></li><li><p>schon länger darüber nachdenke, wie gut es wohl funktioniert, einen zufälligen Fahrrad-Routenvorschlag nach eigenem Gusto zu erzeugen</p></li><li><p>schon länger im Fediverse (Mastodon) bin und während des Alle-Verlassen-Twitter-Hypes einen Bot zu bauen nahe liegt</p></li></ul><p>Also los geht’s. How hard can it be?</p><p>Zunächst soll nicht unerwähnt bleiben, dass Dienste wie Strava erlauben, eine zufällige Route zu erzeugen; meinen Geschmack treffen die Ergebnisse jedoch eher selten. Wenn man “nur Straße” auswählt, wird man häufig über Staats- und teilweise auch Bundesstraßen geführt, was ich (insbesondere alleine) ätzend finde.</p><h2 id=kartenmaterial>Kartenmaterial<a hidden class=anchor aria-hidden=true href=#kartenmaterial>#</a></h2><p>Ganz grundsätzlich brauchen wir zunächst einmal Kartenmaterial, weil eine Route ohne Straßen und Karte nicht funktioniert. Zum Glück gibt es das großartige Projekt <a href=https://openstreetmap.org/>OpenStreetMap</a>, bei dem viele Freiwillige Kartendaten zusammen tragen. Meist in sehr hoher Qualität, und das auch was Nebenstraßen angeht. Und gerade dort macht es mit dem Rad auch einen großen Unterschied, wie es um Belag und Oberflächenbeschaffenheit bestellt ist.</p><p>OpenStreetMap ist erstmal eine große Datenbank, in der alle möglichen Informationen “gemapped” sind. Das geht beim Offensichtlichen los: Straßen und Häuser. Umfasst aber auch Gleise, Läden & Cafes, Stromtrassen, Bushaltestellen, Glascontainer, Mülleimer, Bänke … kurzum alles, was irgendwie mit Geodaten zu tun hat und zu dem sich bisher Freiwillige fanden, es einzupflegen. An diesen Elementen hängen dann mit Schlüssel-Wert-Paaren weitere Informationen, wie beispielsweise Straßenbelag, Wegbeschaffenheit, Gehsteig vorhanden, Beleuchtet, etc.</p><p>Uns interessieren davon erstmal nur Wege. Und da nur die Typen <code>highway</code> (Straße), <code>track</code> (sonstige Wege) und <code>path</code> (Pfade). Die Straßen sind dabei weiter detailliert, sodass man Bundesstraßen (<code>primary</code>), Staatsstraßen (<code>secondary</code>), Kreisstraßen (<code>tertiary</code>), Ortsverbindungsstraßen (<code>unclassified</code>), etc. auseinanderhalten kann.</p><h2 id=ein-naiver-erster-ansatz>Ein (naiver) erster Ansatz<a hidden class=anchor aria-hidden=true href=#ein-naiver-erster-ansatz>#</a></h2><p>Wir haben einen Startpunkt und eine grobe Idee von der Streckenlänge. Anschließend …</p><ol><li><p>berechnen wir den Radius eines Kreises, der im Umfang der gewünschten Streckenlänge entspricht</p></li><li><p>wählen wir einen zufälligen Kreis dieses Radiuses, der unseren Startpunkt schneidet (damit bestimmen wir die Himmelsrichtung in die die Runde geht)</p></li><li><p>wählen wir fünf zufällige Checkpoints, die auf diesem Kreis liegen (wobei einer der Startpunkt ist)</p></li><li><p>suchen wir für jeden Checkpoint einen Punkt, den wir potentiell anfahren wollen/können (anders ausgedrückt: suche den nächst gelegenen Punkt, der auf einer Kreis- oder Ortsverbindungsstraße liegt – schließlich wollen wir nicht viermal auf den Acker laufen)</p></li><li><p>suchen wir eine Route von Checkpoint zu Checkpoint</p></li></ol><p>… damit haben wir eine Route. Um diese dann auf Mastodon zu bringen, brauchen wir einerseits einen API-Client, andererseits noch eine Möglichkeit, die Route auf einer Karte darzustellen. Weil ohne Bild wäre der Tröt (“Tweet” in Mastodon-Lingo) wenig attraktiv.</p><h2 id=bestandsaufnahme>Bestandsaufnahme<a hidden class=anchor aria-hidden=true href=#bestandsaufnahme>#</a></h2><p>Nachdem wir das nicht alles selbst bauen wollen, brauchen wir im Wesentlichen also</p><ul><li><p>einen “fernsteuerbaren” Router</p></li><li><p>eine Möglichkeit, wie wir die nächstgelegene geeignete Straße zu einem gegebenen Punkt finden können.</p></li></ul><p>Besagter Router muss nicht nur skriptbar sein und auf OpenStreetMap fußen, sondern soll flexibel/clever genug sein was die Streckenauswahl betrifft und – optional – auch das Höhenprofil berücksichtigen.</p><p>Hier kommt <a href=https://brouter.de/>BRouter</a> ins Spiel. Das ist eine Java-Anwendung (ursprünglich für Android), die man mit einem Routing-Profil füttern kann, und dann via HTTP die “beste” Strecke zwischen zwei (oder mehr) Punkten abfragen kann.
Besagter BRouter bringt auch gleich ein Profil mit dem tollen Namen <a href=https://github.com/abrensch/brouter/blob/master/misc/profiles2/fastbike-verylowtraffic.brf>fastbike-verylowtraffic</a> mit, das genau das tut was es verspricht: nur befestigte Wege, wenn möglich Kreis- oder Ortsverbindungsstraßen und Radwege. Standardmäßig ohne Berücksichtigung der Höhenmeter, das kann man auf Wunsch jedoch aktivieren.</p><p>Bei der initialen Suche nach geeigneten Checkpoints bietet sich die <a href=http://overpass-api.de/>Overpass API</a> an. Dieser kann man beliebige Anfragen in einer speziellen Abfragesprache (<a href=https://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL>Overpass Query Language</a>) stellen. Im einfachsten Fall die Suche nach z. B. einem Geldautomaten in einem bestimmten Bereich (typischerweise rechteckig). Es gibt jedoch auch einen <code>around</code>-Filter, mit dem man Objekte relativ zu anderen Elementen suchen kann.</p><p>Die Abfrage selbst wirkt zunächst arkan:</p><pre tabindex=0><code>    [out:json];
    (way
        [highway~&#39;tertiary|unclassified&#39;]
        (around:1000.0,49.84178672462459,10.06466533810437);
        &gt;;
    );
    out;
</code></pre><p>Sehen wir uns die Abfrage genauer an:</p><ul><li><p>wir fordern eine Antwort in JSON (statt XML)</p></li><li><p>suchen einen/alle Weg/e</p><ul><li><p>mit Attribut <code>highway=tertiary</code> oder <code>highway=unclassified</code></p></li><li><p>im Umkreis von 1000 Metern um einen gegebenen Punkt</p></li></ul></li><li><p>von den so selektierten Wegen sollen sodann die Punkte (aka parents) abgefragt werden (<code>>;</code>)</p></li><li><p>und das Ergebnis wollen wir auch haben (<code>out;</code>)</p></li></ul><h2 id=umsetzung>Umsetzung<a hidden class=anchor aria-hidden=true href=#umsetzung>#</a></h2><p>Meine Lieblingsprogrammiersprache ist TypeScript. Eine kurze Recherche hat gezeigt, dass es gut gepflegte NPM-Module zum Ansprechen von Overpass (<code>overpass-ts</code>) und für erdräumliche Berechnungen (<code>@turf/turf</code>) gibt.</p><p>Alle Funktionen von <code>turf</code> basieren auf GeoJSON, einem offenem Format, um eben geografische Daten in Form sog. Features zu repräsentieren. Solche Features können dann Punkte, Linien oder Polygone sein.</p><p>Um den Ablauf des Skriptes transparenter zu bekommen, bietet es sich an, sämtliche Zwischenschritte als GeoJSON-<code>FeatureCollection</code> abzuspeichern. Unter geojson.io findet sich ein Online-Viewer, in den man jenes GeoJSON dann kopieren (und sodann betrachten) kann.</p><p>An diesem lässt sich dann gut erkennen, wie die Anwendung Schritt für Schritt vorgeht:</p><p><img loading=lazy src=/assets/mastodon-bot_1.jpg alt="Vorschau über geojson.io"></p><h2 id=was-passiert-hier-eigentlich>Was passiert hier eigentlich?<a hidden class=anchor aria-hidden=true href=#was-passiert-hier-eigentlich>#</a></h2><p>Sehen wir uns nun einmal im Detail an, was auf diesem Bild alles zu sehen ist:</p><ol><li><p>der Startpunkt (= grauer Marker) direkt in Würzburg</p></li><li><p>Kreis um diesen ziehen und einen Punkt davon als Routenmittelpunkt bestimmen (= grüner Marker)</p></li><li><p>Kreis um den grünen Marker bestimmen und fünf Checkpunkte auf diesem festlegen (= graues Polygon)</p></li><li><p>für alle Ecken (mit Overpass) die nächstgelegene (geeignete) Straße finden (= gelbliche Marker/Polygon)</p></li><li><p>mit BRouter Routen zwischen ebendiesen Punkten erstellen (= rote Linien)</p></li><li><p>“dead ends” entfernen, also Wege, die zu gelben Markern führen und dann direkt wieder zurück (= rote Marker)</p></li></ol><p>Die Koordinaten von Startpunkt und (korrigierten) Checkpoint-Markern können wir dann ein letztes mal dem BRouter füttern, der daraus eine GPX-Datei zaubert. GPX (= GPS Exchange Format) ist ein offenes XML-Format, mit dem Routen beschrieben werden können und das von den üblichen GPS-Geräten verstanden wird.</p><p>Der o.g. Viewer für GeoJSON kann übrigens, trotz des Namens, auch GPX laden.</p><h2 id=grafik-rendern>Grafik rendern<a hidden class=anchor aria-hidden=true href=#grafik-rendern>#</a></h2><p>Ein Tröt ohne Bild ist langweilig. Aber wie bekommen wir einen Screenshot einer Karte mit unserer Route darauf?</p><p>Vielleicht nicht die effizienteste Lösung, aber zumindest straight forward: wir nehmen einfach einen Browser plus die Standard-JavaScript-Library zum Kartenrendering: <a href=https://leafletjs.com/>Leaflet</a> nebst <a href=https://github.com/mpetazzoni/leaflet-gpx>GPX-Track-Plugin</a>.</p><p>Nun brauchen wir nur noch etwas, das uns den Screenshot auf Kommando anfertigt: <a href=https://github.com/GoogleChrome/rendertron>Googles Rendertron</a>. Rendertron kann man auch wieder einfach per HTTP aufrufen, die URL übergeben (+ gewünschte Größe) und bekommt den Screenshot im JPG-Format zurück.</p><p><img loading=lazy src=/assets/mastodon-bot_2.jpg alt="Unsere fertig gerenderte Route."></p><h2 id=automatisch-tröten>Automatisch Tröten<a hidden class=anchor aria-hidden=true href=#automatisch-tröten>#</a></h2><p>Jetzt brauchen wir noch einen (Bot-)Account auf der Mastodon-Instanz unserer Wahl. In meinem Fall ist das <a href=https://wue.social/>wue.social</a>. Und ein CLI-Tool, mit dem wir Route nebst Bild tröten können: <a href=https://toot.readthedocs.io/en/latest/index.html>toot</a>.</p><p>Das Ergebnis all der Arbeit? Ein Tröt:</p><p><img loading=lazy src=/assets/mastodon-bot_3.jpg alt="… und fertig ist der Tröt."></p><p>Damit kann unser Mashup auf die Zielgerade: noch ein bisschen Docker und ein paar Cronjobs – fertig ist der Bot :-)</p><h2 id=-und-der-ganze-rest>… und der ganze Rest<a hidden class=anchor aria-hidden=true href=#-und-der-ganze-rest>#</a></h2><p>Natürlich kann ich euch viel erzählen – ihr könnt euch aber auch selbst vom Bot überzeugen:</p><p>Profilseite des Bots: <a href=https://wue.social/web/@rbrb>@rbrb</a></p><p><a href=https://github.com/stesie/routebot>Quellcode des Projekts</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://stesie.github.io/tags/bot/>Bot</a></li><li><a href=https://stesie.github.io/tags/geodaten/>Geodaten</a></li><li><a href=https://stesie.github.io/tags/mastodon/>Mastodon</a></li><li><a href=https://stesie.github.io/tags/openstreetmap/>OpenStreetMap</a></li></ul></footer></article></main><footer class=footer><span>© 2025 Stefan Siegl · all content is <a href=https://creativecommons.org/licenses/by-sa/4.0/deed>CC-BY-SA</a></span> ·
<a href=/imprint>Imprint</a> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>