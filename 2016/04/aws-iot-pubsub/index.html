<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Serverless Pub Sub with AWS IoT | ~stesie's musings</title>
<meta name=keywords content="AWS,IoT,PubSub,Javascript,Webapp"><meta name=description content="I&rsquo;m currently very interested in serverless (aka no dedicated backend required) JavaScript Web Applications &mldr; with AWS S3, Lambda & API Gateway you can actually get pretty far. Yet there is one thing I didn&rsquo;t know how to do: Pub/Sub or &ldquo;Realtime Messaging&rdquo;.
Realtime messaging allows to build web applications that can instantly receive messages published by another application (or the same one running in a different person&rsquo;s browser). There even are cloud services permitting to do exactly this, e."><meta name=author content><link rel=canonical href=https://stefansiegl.de/2016/04/aws-iot-pubsub/><link crossorigin=anonymous href=/assets/css/stylesheet.0669d81ae9c5ebf0731aafcbac037c15b990f9546c445660f4b04f769073cc7a.css integrity="sha256-BmnYGunF6/BzGq/LrAN8FbmQ+VRsRFZg9LBPdpBzzHo=" rel="preload stylesheet" as=style><link rel=icon href=https://stefansiegl.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://stefansiegl.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://stefansiegl.de/favicon-32x32.png><link rel=apple-touch-icon href=https://stefansiegl.de/apple-touch-icon.png><link rel=mask-icon href=https://stefansiegl.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://stefansiegl.de/2016/04/aws-iot-pubsub/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Serverless Pub Sub with AWS IoT"><meta property="og:description" content="I&rsquo;m currently very interested in serverless (aka no dedicated backend required) JavaScript Web Applications &mldr; with AWS S3, Lambda & API Gateway you can actually get pretty far. Yet there is one thing I didn&rsquo;t know how to do: Pub/Sub or &ldquo;Realtime Messaging&rdquo;.
Realtime messaging allows to build web applications that can instantly receive messages published by another application (or the same one running in a different person&rsquo;s browser). There even are cloud services permitting to do exactly this, e."><meta property="og:type" content="article"><meta property="og:url" content="https://stefansiegl.de/2016/04/aws-iot-pubsub/"><meta property="article:section" content="pages"><meta property="article:published_time" content="2016-04-02T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-03T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Serverless Pub Sub with AWS IoT"><meta name=twitter:description content="I&rsquo;m currently very interested in serverless (aka no dedicated backend required) JavaScript Web Applications &mldr; with AWS S3, Lambda & API Gateway you can actually get pretty far. Yet there is one thing I didn&rsquo;t know how to do: Pub/Sub or &ldquo;Realtime Messaging&rdquo;.
Realtime messaging allows to build web applications that can instantly receive messages published by another application (or the same one running in a different person&rsquo;s browser). There even are cloud services permitting to do exactly this, e."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Pages","item":"https://stefansiegl.de/pages/"},{"@type":"ListItem","position":2,"name":"Serverless Pub Sub with AWS IoT","item":"https://stefansiegl.de/2016/04/aws-iot-pubsub/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Serverless Pub Sub with AWS IoT","name":"Serverless Pub Sub with AWS IoT","description":"I\u0026rsquo;m currently very interested in serverless (aka no dedicated backend required) JavaScript Web Applications \u0026hellip; with AWS S3, Lambda \u0026amp; API Gateway you can actually get pretty far. Yet there is one thing I didn\u0026rsquo;t know how to do: Pub/Sub or \u0026ldquo;Realtime Messaging\u0026rdquo;.\nRealtime messaging allows to build web applications that can instantly receive messages published by another application (or the same one running in a different person\u0026rsquo;s browser). There even are cloud services permitting to do exactly this, e.","keywords":["AWS","IoT","PubSub","Javascript","Webapp"],"articleBody":"I’m currently very interested in serverless (aka no dedicated backend required) JavaScript Web Applications … with AWS S3, Lambda \u0026 API Gateway you can actually get pretty far. Yet there is one thing I didn’t know how to do: Pub/Sub or “Realtime Messaging”.\nRealtime messaging allows to build web applications that can instantly receive messages published by another application (or the same one running in a different person’s browser). There even are cloud services permitting to do exactly this, e.g. Realtime Messaging Platform and PubNub Data Streams …\nHowever recently having played with AWS Lambda and S3 I was wondering how this could be achieved on AWS… and at first it seemed like it really isn’t possible. Especially the otherwise very interesting article Receiving AWS IoT messages in your browser using websockets by @jtparreira misled me, as he’s telling that it wouldn’t be possible. The article was published Nov 2015, … not so long ago. But turns out it’s outdated anyways…\nEnter AWS IoT While reading I stumbled over AWS IoT which allows to connect “Internet of Things” devices to the AWS cloud and furthermore provides messaging between those devices. It has a message broker (aka Device Gateway) sitting in the middle and “things” around it that connect to it. It’s based on the MQTT protocol and there are SDKs for the Raspberry Pi (Node.js), Android \u0026 iOS … sound’s interesting, but not at all like “web browsers”\nMQTT over Web Sockets Then I found an announcement: AWS IoT Now Supports WebSockets published Jan 28, 2016. Brand new, but sounds great :)\n… so even when IoT still sounds strange to do Pub/Sub with - it looks like a way to go.\nMaking it work For the proof of concept I didn’t care to publish AWS IAM User keys to the web application (of course this is a smell to be fixed before production use). So I went to “IAM” in the AWS management console and created a new user first, attaching the pre-defined AWSIoTDataAccess policy.\nSo the proof of concept should involve a simple web page that allows to establish a connection to the broker, features a text box where a message can be typed plus a publish button. So if two browsers are connected simultaneously then both should immediately receive messages published by one of them.\nrequired parts: … we of course need a MQTT client and we need to do AWS-style request signing in the browser. NPM modules to the rescue:\naws-signature-v4 does the signature calculation\ncrypto helps it + some extra hashing we need to do\nmqtt has an MqttClient\n… all of them have browser support through webpack. So we just need some more JavaScript to string everything together. To set up the connection:\nlet client = new MqttClient(() =\u003e { const url = v4.createPresignedURL( 'GET', AWS_IOT_ENDPOINT_HOST.toLowerCase(), '/mqtt', 'iotdevicegateway', crypto.createHash('sha256').update('', 'utf8').digest('hex'), { 'key': AWS_ACCESS_KEY, 'secret': AWS_SECRET_ACCESS_KEY, 'protocol': 'wss', 'expires': 15 } ); return websocket(url, [ 'mqttv3.1' ]); }); … here createPresignedURL from aws-signature-v4 first does the heavy-lifting for us. We tell it the IoT endpoint address, protocol plus AWS credentials and it provides us with the signed URL to connect to.\nThere was just one stumbling block to me: I had upper-case letters in the hostname (as it is output by aws iot describe-endpoint command), the module however doesn’t convert these to lower case as expected by AWS’ V4 signing process … and as a matter of that access was denied first.\nHaving the signed URL we simply pass it on to a websocket-stream and create a new MqttClient instance around it.\nConnection established … time to subscibe to a topic. Turns out to be simple:\nclient.on('connect', () =\u003e client.subscribe(MQTT_TOPIC)); Handling incoming messages … also easy:\nclient.on('message', (topic, message) =\u003e console.log(message.toString())); … and last not least publishing messages … trivial again:\nclient.publish(MQTT_TOPIC, message); … that’s it :-)\nMy proof of concept here’s what it looks like:\n… the last incoming message was published from another browser running the exact same application.\nI’ve published my source code as a Gist on Github, feel free to re-use it.\nTo try it yourself:\nclone the Gist\nadjust the constants declared at the top of main.js as needed\ncreate a user in IAM first, see above\nfor the endpoint host run aws iot describe-endpoint CLI command\nrun npm install\nrun ./node_modules/.bin/webpack-dev-server --colors\nNext steps This was just the first (big) part. There’s more stuff left to be done:\nneither is hard-coding AWS credentials into the application source the way to go nor is publishing the secret key at all\n… one possible approach would be to use the API Gateway + Lambda to create pre-signed URLs\n… this could be further limited by using IAM roles and temporary identity federation (through STS Token Service)\nthere’s no user authentication yet, this should be achievable with AWS Cognito\n… with that publishing/subscribing could be limitted to identity-related topics (depends on the use case)\n","wordCount":"822","inLanguage":"en","datePublished":"2016-04-02T00:00:00Z","dateModified":"2025-01-03T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://stefansiegl.de/2016/04/aws-iot-pubsub/"},"publisher":{"@type":"Organization","name":"~stesie's musings","logo":{"@type":"ImageObject","url":"https://stefansiegl.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://stefansiegl.de/ accesskey=h title="~stesie's musings (Alt + H)">~stesie's musings</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://stefansiegl.de/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://stefansiegl.de/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://stefansiegl.de/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://stefansiegl.de/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Serverless Pub Sub with AWS IoT</h1><div class=post-meta>Planted:&nbsp;<span title='2016-04-02 00:00:00 +0000 UTC'>Apr 2, 2016</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><p>I&rsquo;m currently very interested in serverless (aka no dedicated backend required) JavaScript Web Applications &mldr; with AWS S3, Lambda & API Gateway you can actually get pretty far.
Yet there is one thing I didn&rsquo;t know how to do: Pub/Sub or &ldquo;Realtime Messaging&rdquo;.</p><p>Realtime messaging allows to build web applications that can instantly receive messages published by another application (or the same one running in a different person&rsquo;s browser). There even are cloud services permitting to do exactly this, e.g. <a href=http://framework.realtime.co/messaging/>Realtime Messaging Platform</a> and <a href=https://www.pubnub.com/products/publish-subscribe/>PubNub Data Streams</a> &mldr;</p><p>However recently having played with AWS Lambda and S3 I was wondering how this could be achieved on AWS&mldr; and at first it seemed like it really isn&rsquo;t possible. Especially the otherwise very interesting article <a href=https://medium.com/@jparreira/receiving-aws-iot-messages-in-your-browser-using-websockets-9b87f28c2357>Receiving AWS IoT messages in your browser using websockets</a> by @jtparreira misled me, as he&rsquo;s telling that it wouldn&rsquo;t be possible. The article was published Nov 2015, &mldr; not so long ago. But turns out it&rsquo;s outdated anyways&mldr;</p><h2 id=enter-aws-iot>Enter AWS IoT<a hidden class=anchor aria-hidden=true href=#enter-aws-iot>#</a></h2><p>While reading I stumbled over <a href=https://aws.amazon.com/iot/>AWS IoT</a> which allows to connect &ldquo;Internet of Things&rdquo; devices to the AWS cloud and furthermore provides messaging between those devices. It has a message broker (aka Device Gateway) sitting in the middle and &ldquo;things&rdquo; around it that connect to it. It&rsquo;s based on the MQTT protocol and there are SDKs for the Raspberry Pi (Node.js), Android & iOS &mldr; sound&rsquo;s interesting, but not at all like &ldquo;web browsers&rdquo;</p><h2 id=mqtt-over-web-sockets>MQTT over Web Sockets<a hidden class=anchor aria-hidden=true href=#mqtt-over-web-sockets>#</a></h2><p>Then I found an announcement: <a href=https://aws.amazon.com/about-aws/whats-new/2016/01/aws-iot-now-supports-websockets-custom-keepalive-intervals-and-enhanced-console/>AWS IoT Now Supports WebSockets</a> published Jan 28, 2016.
Brand new, but sounds great :)</p><p>&mldr; so even when IoT still sounds strange to do Pub/Sub with - it looks like a way to go.</p><h2 id=making-it-work>Making it work<a hidden class=anchor aria-hidden=true href=#making-it-work>#</a></h2><p>For the proof of concept I didn&rsquo;t care to publish AWS IAM User keys to the web application (of course this is a smell to be fixed before production use). So I went to &ldquo;IAM&rdquo; in the AWS management console and created a new user first, attaching the pre-defined <code>AWSIoTDataAccess</code> policy.</p><p>So the proof of concept should involve a simple web page that allows to establish a connection to the broker, features a text box where a message can be typed plus a publish button. So if two browsers are connected simultaneously then both should immediately receive messages published by one of them.</p><p>required parts: &mldr; we of course need a MQTT client and we need to do AWS-style request signing in the browser. NPM modules to the rescue:</p><ul><li><p><code>aws-signature-v4</code> does the signature calculation</p></li><li><p><code>crypto</code> helps it + some extra hashing we need to do</p></li><li><p><code>mqtt</code> has an MqttClient</p></li></ul><p>&mldr; all of them have browser support through <code>webpack</code>. So we just need some more JavaScript to string everything together. To set up the connection:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>client</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>MqttClient</span>(() =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>url</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>v4</span>.<span style=color:#a6e22e>createPresignedURL</span>(
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#39;GET&#39;</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>AWS_IOT_ENDPOINT_HOST</span>.<span style=color:#a6e22e>toLowerCase</span>(),
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#39;/mqtt&#39;</span>,
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#39;iotdevicegateway&#39;</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>crypto</span>.<span style=color:#a6e22e>createHash</span>(<span style=color:#e6db74>&#39;sha256&#39;</span>).<span style=color:#a6e22e>update</span>(<span style=color:#e6db74>&#39;&#39;</span>, <span style=color:#e6db74>&#39;utf8&#39;</span>).<span style=color:#a6e22e>digest</span>(<span style=color:#e6db74>&#39;hex&#39;</span>),
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>          <span style=color:#e6db74>&#39;key&#39;</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>AWS_ACCESS_KEY</span>,
</span></span><span style=display:flex><span>          <span style=color:#e6db74>&#39;secret&#39;</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>AWS_SECRET_ACCESS_KEY</span>,
</span></span><span style=display:flex><span>          <span style=color:#e6db74>&#39;protocol&#39;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;wss&#39;</span>,
</span></span><span style=display:flex><span>          <span style=color:#e6db74>&#39;expires&#39;</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>websocket</span>(<span style=color:#a6e22e>url</span>, [ <span style=color:#e6db74>&#39;mqttv3.1&#39;</span> ]);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>&mldr; here <code>createPresignedURL</code> from <code>aws-signature-v4</code> first does the heavy-lifting for us. We tell it the IoT endpoint address, protocol plus AWS credentials and it provides us with the signed URL to connect to.</p><p>There was just one stumbling block to me: I had upper-case letters in the hostname (as it is output by <code>aws iot describe-endpoint</code> command), the module however doesn&rsquo;t convert these to lower case as expected by AWS&rsquo; V4 signing process &mldr; and as a matter of that access was denied first.</p><p>Having the signed URL we simply pass it on to a <code>websocket-stream</code> and create a new <code>MqttClient</code> instance around it.</p><p>Connection established &mldr; time to subscibe to a topic. Turns out to be simple:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#39;connect&#39;</span>, () =&gt; <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>subscribe</span>(<span style=color:#a6e22e>MQTT_TOPIC</span>));
</span></span></code></pre></div><p>Handling incoming messages &mldr; also easy:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#39;message&#39;</span>, (<span style=color:#a6e22e>topic</span>, <span style=color:#a6e22e>message</span>) =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>message</span>.<span style=color:#a6e22e>toString</span>()));
</span></span></code></pre></div><p>&mldr; and last not least publishing messages &mldr; trivial again:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>publish</span>(<span style=color:#a6e22e>MQTT_TOPIC</span>, <span style=color:#a6e22e>message</span>);
</span></span></code></pre></div><p>&mldr; that&rsquo;s it :-)</p><h2 id=my-proof-of-concept>My proof of concept<a hidden class=anchor aria-hidden=true href=#my-proof-of-concept>#</a></h2><p>here&rsquo;s what it looks like:</p><p><img loading=lazy src=/assets/pubsub-demo.png alt="screenshot of demo web page"></p><p>&mldr; the last incoming message was published from another browser running the exact same application.</p><p>I&rsquo;ve published my source code <a href=https://gist.github.com/stesie/dabc9236ef8fc4123609f9d81df6ccd8>as a Gist on Github</a>, feel free to re-use it.</p><p>To try it yourself:</p><ul><li><p>clone the Gist</p></li><li><p>adjust the constants declared at the top of <code>main.js</code> as needed</p><ul><li><p>create a user in IAM first, see above</p></li><li><p>for the endpoint host run <code>aws iot describe-endpoint</code> CLI command</p></li></ul></li><li><p>run <code>npm install</code></p></li><li><p>run <code>./node_modules/.bin/webpack-dev-server --colors</code></p></li></ul><h2 id=next-steps>Next steps<a hidden class=anchor aria-hidden=true href=#next-steps>#</a></h2><p>This was just the first (big) part. There&rsquo;s more stuff left to be done:</p><ul><li><p>neither is hard-coding AWS credentials into the application source the way to go nor is publishing the secret key at all</p></li><li><p>&mldr; one possible approach would be to use the API Gateway + Lambda to create pre-signed URLs</p></li><li><p>&mldr; this could be further limited by using IAM roles and temporary identity federation (through STS Token Service)</p></li><li><p>there&rsquo;s no user authentication yet, this should be achievable with <a href=https://aws.amazon.com/cognito/>AWS Cognito</a></p></li><li><p>&mldr; with that publishing/subscribing could be limitted to identity-related topics (depends on the use case)</p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://stefansiegl.de/tags/aws/>AWS</a></li><li><a href=https://stefansiegl.de/tags/iot/>IoT</a></li><li><a href=https://stefansiegl.de/tags/pubsub/>PubSub</a></li><li><a href=https://stefansiegl.de/tags/javascript/>Javascript</a></li><li><a href=https://stefansiegl.de/tags/webapp/>Webapp</a></li></ul></footer></article></main><footer class=footer><span>© 2025 Stefan Siegl · all content is <a href=https://creativecommons.org/licenses/by-sa/4.0/deed>CC-BY-SA</a> · <a href=https://www.swyx.io/digital-garden-tos#for-visitors>Terms of Service</a></span> ·
<a href=/imprint>Imprint</a> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>