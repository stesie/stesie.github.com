<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Java Agents on ~stesie's musings</title><link>https://stefansiegl.de/tags/java-agents/</link><description>Recent content in Java Agents on ~stesie's musings</description><generator>Hugo -- 0.123.7</generator><language>en-us</language><copyright>2025 Stefan Siegl Â· all content is CC-BY-SA Â· Terms of Service</copyright><lastBuildDate>Sat, 01 Mar 2025 18:30:00 +0000</lastBuildDate><atom:link href="https://stefansiegl.de/tags/java-agents/feed.xml" rel="self" type="application/rss+xml"/><item><title>Let's create a Coverage Analyzer, Part 4</title><link>https://stefansiegl.de/2025/03/lets-create-a-coverage-analyzer-part-4/</link><pubDate>Sat, 01 Mar 2025 18:30:00 +0000</pubDate><guid>https://stefansiegl.de/2025/03/lets-create-a-coverage-analyzer-part-4/</guid><description>This is part four of my journey creating a Java (Line) Coverage Analyzer.
This time around we&amp;rsquo;ll test the implementation created in part three and look into details what still goes wrong.
One (simplified) example that crashes the current analyzer implementation is this one:
public class Demo3 { public static void main(final String[] argv) { final Stuff stuff = new Stuff( !getBoolean()); bla(&amp;#34;value: &amp;#34; + stuff.boolValue()); } public static boolean getBoolean() { return true; } private static void bla(final String greeting) { System.</description></item><item><title>Let's create a Coverage Analyzer, Part 3</title><link>https://stefansiegl.de/2025/03/lets-create-a-coverage-analyzer-part-3/</link><pubDate>Sat, 01 Mar 2025 11:00:00 +0000</pubDate><guid>https://stefansiegl.de/2025/03/lets-create-a-coverage-analyzer-part-3/</guid><description>This is part three of my journey creating a Java (Line) Coverage Analyzer.
This time around we&amp;rsquo;ll look into improving the very naive implementation created in part two. That one ended in a VerifyError and the message
Expecting a stackmap frame at branch target 41
So what is this branch target, and the stackmap frame that it&amp;rsquo;s suddenly missing? To have an easier time inspecting the Byte Code, let&amp;rsquo;s first create a little CLI version of our instrumentation code.</description></item><item><title>Let's create a Coverage Analyzer, Part 2</title><link>https://stefansiegl.de/2025/02/lets-create-a-coverage-analyzer-part-2/</link><pubDate>Wed, 26 Feb 2025 00:00:00 +0000</pubDate><guid>https://stefansiegl.de/2025/02/lets-create-a-coverage-analyzer-part-2/</guid><description>This is part two of my journey creating a Java (Line) Coverage Analyzer.
Here we&amp;rsquo;ll actually implement the Byte Code Instrumentation, as pointed out in the first part.
Since processing the Byte Code itself, i.e. reading the classes, finding the methods, processing line number information, is in itself a huge task, let&amp;rsquo;s rely on the ASM library for that. After all JaCoCo and Cobertura also rely on that, so this seems to be a valid choice ðŸ˜‚</description></item><item><title>Let's create a Coverage Analyzer, Part 1</title><link>https://stefansiegl.de/2025/02/lets-create-a-coverage-analyzer-part-1/</link><pubDate>Mon, 17 Feb 2025 00:00:00 +0000</pubDate><guid>https://stefansiegl.de/2025/02/lets-create-a-coverage-analyzer-part-1/</guid><description>Have you ever wondered what happens when you click on &amp;ldquo;Run with Coverage&amp;rdquo; in IntelliJ? Obviously it&amp;rsquo;s running the tests, but how is it collecting the coverage information?
Let&amp;rsquo;s create a simple Line Coverage Analyzer in and for Java ðŸ¥³
First of all, let&amp;rsquo;s write a simple example program (see GitHub)
package de.brokenpipe.dojo.undercovered.demo; public class Demo { public static void main(final String[] argv) { final String greeting = &amp;#34;Hello World&amp;#34;; bla(greeting); bla(&amp;#34;to the blarg&amp;#34;); } private static void bla(final String greeting) { System.</description></item></channel></rss>