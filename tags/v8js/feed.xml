<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>V8Js on stesie's musings</title><link>https://stesie.github.io/tags/v8js/</link><description>Recent content in V8Js on stesie's musings</description><generator>Hugo -- 0.123.7</generator><language>en-us</language><copyright>2025 Stefan Siegl · all content is CC-BY-SA</copyright><lastBuildDate>Fri, 03 Jan 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://stesie.github.io/tags/v8js/feed.xml" rel="self" type="application/rss+xml"/><item><title>Heroku custom platform repo for V8Js</title><link>https://stesie.github.io/2016/03/heroku-custom-platform-repo/</link><pubDate>Mon, 28 Mar 2016 00:00:00 +0000</pubDate><guid>https://stesie.github.io/2016/03/heroku-custom-platform-repo/</guid><description>Yesterday @dzuelke poked me to migrate the old PHP buildpack adjusted for V8Js to the new custom platform repo infrastructure. The advantage is that the custom platform repo only contains the v8js extension packages now, the rest (i.e. Apache and PHP itself) are pulled from the lang-php bucket, aka normal php buildpack.
As I already had that on my TODO list, I just immediately did that :-)
&amp;hellip; so here&amp;rsquo;s the new heroku-v8js Github repository that has all the build formulas.</description></item><item><title>V8Js improved fluent setter performance</title><link>https://stesie.github.io/2016/03/fluent-setters/</link><pubDate>Fri, 25 Mar 2016 00:00:00 +0000</pubDate><guid>https://stesie.github.io/2016/03/fluent-setters/</guid><description>After fixing V8Js&amp;rsquo; behaviour of not retaining the object identity of passed back V8Object instances (i.e. always re-wrapping them, instead of re-using the already existing object) I tried how V8Js handles fluent setters (those that return $this at the end).
Unfortunately they weren&amp;rsquo;t handled well, that is V8Js always wrapped the same object again and again (in both directions). Functionality-wise that doesn&amp;rsquo;t make a big difference since the underlying object is the same, hence further setters can still be called.</description></item><item><title>V8PromiseFactory</title><link>https://stesie.github.io/2016/03/v8promisefactory/</link><pubDate>Fri, 25 Mar 2016 00:00:00 +0000</pubDate><guid>https://stesie.github.io/2016/03/v8promisefactory/</guid><description>V8 has support for ES6 Promises and they make a clean JS-side API. So why not create promises from PHP, (later on) being resolved by PHP?
V8Js doesn&amp;rsquo;t allow direct creation of JS objects from PHP-code, a little JS-side helper needs to be used. One possibility is this:
class V8PromiseFactory { private $v8; public function __construct(V8Js $v8) { $this-&amp;gt;v8 = $v8; } public function __invoke($executor) { $trampoline = $this-&amp;gt;v8-&amp;gt;executeString( &amp;#39;(function(executor) { return new Promise(executor); })&amp;#39;); return $trampoline($executor); } } &amp;hellip; it can be used to construct an API method that returns a Promise like this:</description></item><item><title>funny Math.random behaviour</title><link>https://stesie.github.io/2016/03/math-random-fun/</link><pubDate>Sat, 05 Mar 2016 00:00:00 +0000</pubDate><guid>https://stesie.github.io/2016/03/math-random-fun/</guid><description>Playing around with V8&amp;rsquo;s custom startup snapshots I noticed some funny behaviour regarding Math.random.
It is clear that if you call Math.random() within the custom startup code the generated random numbers are baked into the snapshot and then not so random anymore. If you call Math.random() at runtime, without custom startup code, it just behaves as expected: it generates random numbers. However if you have custom startup code, calling Math.random() early on startup, it correctly generates random numbers during startup but it breaks runtime random number generation causing weird error messages like</description></item><item><title>20x performance boost with V8Js snapshots</title><link>https://stesie.github.io/2016/02/snapshot-performance/</link><pubDate>Mon, 29 Feb 2016 00:00:00 +0000</pubDate><guid>https://stesie.github.io/2016/02/snapshot-performance/</guid><description>Recently @virgofx filed an issue on V8Js whether (startup) performance of V8Js could be increased. He wants to do server-side React rendering and noticed that V8 itself needs roughly 50ms to initialize and then further 60ms to process React &amp;amp; ReactServer javascript code. Way too much for server side rendering (on more or less every request).
Up to V8 4.4 you simply could compile it with snapshots and V8Js made use of them.</description></item><item><title>V8Js approaching PHP7</title><link>https://stesie.github.io/2015/10/v8js-on-php7/</link><pubDate>Mon, 05 Oct 2015 00:00:00 +0000</pubDate><guid>https://stesie.github.io/2015/10/v8js-on-php7/</guid><description>For some weeks now I had the idea that V8Js must be running on PHP7 the day it is officially published. So when I started out porting soon after they published he first release candidate (aka 7.0.0RC1) I felt some pressure, especially after noticing that it really will be a lot of work to do.
The more glad I am to announce today, that V8Js finally compiles fine and passes the whole test suite from the master branch (apart from tiny modifications that became necessary due to PHP 5.</description></item><item><title>Two more V8Js releases</title><link>https://stesie.github.io/2015/09/two-more-releases/</link><pubDate>Tue, 01 Sep 2015 00:00:00 +0000</pubDate><guid>https://stesie.github.io/2015/09/two-more-releases/</guid><description>Today as well as last Thursday I uploaded two more V8Js releases to PECL, both fixing issues around v8::FunctionTemplate usage that bit me at work.
Those v8::FunctionTemplate objects are used to construct constructor functions (and thus object templates) in V8. The problem with them? They are not object to garbage collection. So if we export a object with a method attached to it from PHP to JS, V8Js at first exports the object (and caches the v8::FunctionTemplate used to construct it; re-using it on subsequent export of the same class).</description></item><item><title>Poor V8Function call performance</title><link>https://stesie.github.io/2015/08/poor-v8js-function-call-performance/</link><pubDate>Wed, 26 Aug 2015 00:00:00 +0000</pubDate><guid>https://stesie.github.io/2015/08/poor-v8js-function-call-performance/</guid><description>Today I noticed, that invocations of V8Function objects have a really poor call performance. A simple example might be:
$v8 = new V8Js(); $func = $v8-&amp;gt;executeString(&amp;#39;(function() { print(&amp;#34;Hello\\n&amp;#34;); });&amp;#39;); for($i = 0; $i &amp;lt; 1000; $i ++) { $func(); } &amp;hellip; on my laptop this takes 2.466 seconds (with latest V8Js 0.2.1); older versions like V8Js 0.1.5 even take 80 seconds.
That felt strange, since V8Js performance generally is pretty good and the slightly changed version</description></item><item><title>php.net account approved</title><link>https://stesie.github.io/2015/03/php-account-approved/</link><pubDate>Fri, 13 Mar 2015 00:00:00 +0000</pubDate><guid>https://stesie.github.io/2015/03/php-account-approved/</guid><description>After waiting for a really long time (half a year) I finally have an approved php.net + PECL account granted with lead-rights on V8Js :-)
&amp;hellip; therefore I finally published V8Js version 0.2.0, succeeding 0.1.5 which was published 1.5 years ago.
Changes include
adapt to latest v8 API (v8 versions from 3.24.6 up to latest 4.3 branch supported now)
v8 debugging support
apply time &amp;amp; memory limits to V8Function calls</description></item><item><title>V8Js Patches merged</title><link>https://stesie.github.io/2013/07/v8js-patches-merged/</link><pubDate>Wed, 17 Jul 2013 00:00:00 +0000</pubDate><guid>https://stesie.github.io/2013/07/v8js-patches-merged/</guid><description>Today the last pull request in a series of contributions to the V8Js PHP extension has been merged. Good time to loose some words on the project and why I like it, so here we go :-)
V8Js is a PHP extension that integrates Google&amp;rsquo;s V8 JavaScript engine into PHP. This is the extension allows you to execute JavaScript code securely sandboxed from PHP. Besides it allows for simple exchange of data from PHP to JavaScript and back.</description></item></channel></rss>